<?xml version="1.0"?><st-source><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 11, 2018' '4:01:20 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 4:01:20 AM on March 11, 2018."</do-it><component-created><name>CS474</name> <type>package</type></component-created><bundle-structure><name>StoreBase</name> <structure>#(#(#package 'Store-Base') #(#bundle 'Store-Database Support') #(#bundle 'Store-Image Support') #(#package 'Store-Change Management') #(#package 'Store-User Management') #(#package 'Store-Ownership') #(#bundle 'Store II') #(#bundle 'Store-UI') #(#package 'CS474'))</structure></bundle-structure><bundle-structure><name>StoreBase</name> <structure>#(#(#package 'Store-Base') #(#bundle 'Store-Database Support') #(#bundle 'Store-Image Support') #(#package 'Store-Change Management') #(#package 'Store-User Management') #(#package 'Store-Ownership') #(#bundle 'Store II') #(#bundle 'Store-UI') #(#package 'CS474'))</structure></bundle-structure><class><name>Interpreter_Interface</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Interpreter_Interface</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter_Interface class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>Interpreter_Interface organization addCategory: #Methods</do-it><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="dec:">dec:symbolself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="lda:">lda:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="ldb:">ldb:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="ldi:">ldi:valueself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="st:">st:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="xch">xchself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="jmp:">jmp:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="jzs:">jzs:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="add">addself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="hlt">hltself subclassResponsibility.</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Interpreter_Interface</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Interpreter_Interface</staticKey> <definitionChange>added</definitionChange></component_static_change><bundle-structure><name>StoreBase</name> <structure>#(#(#package 'Store-Base') #(#bundle 'Store-Database Support') #(#bundle 'Store-Image Support') #(#package 'Store-Change Management') #(#package 'Store-User Management') #(#package 'Store-Ownership') #(#bundle 'Store II') #(#bundle 'Store-UI'))</structure></bundle-structure><component-created><name>CS474</name> <type>package</type></component-created><class><name>Interpreter_Interface</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Interpreter_Interface</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter_Interface class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>Interpreter_Interface organization addCategory: #Methods</do-it><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="dec:">dec:numberself subclassResponsibility.</body></methods><remove-selector><class-id>Interpreter_Interface</class-id> <selector>dec:</selector></remove-selector><do-it>Interpreter_Interface organization removeCategory: #Methods</do-it><do-it>Interpreter_Interface organization addCategory: #Methods</do-it><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="dec:">dec:symbolself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="lda:">lda:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="ldb:">ldb:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="ldi:">ldi:valueself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="st:">st:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="xch">xchself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="jmp:">jmp:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="jzs:">jzs:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:numberself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="add">addself subclassResponsibility.</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="hlt">hltself subclassResponsibility.</body></methods><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="dec:">dec:symbol	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="lda:">lda:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="xch">xch	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="add">add	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="st:">st:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="hlt">hlt	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldb:">ldb:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jzs:">jzs:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldi:">ldi:value	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jmp:">jmp:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Memory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'Memory'</do-it><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	Memory:=Array new.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Memory memory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'memory'</do-it><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Memory memory accumulator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'accumulator'</do-it><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	accumulator:=-1.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Memory memory accumulator additional_register </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'additional_register'</do-it><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Memory memory accumulator additional_register program_counter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'program_counter'</do-it><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Memory memory accumulator additional_register program_counter zero_result </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'zero_result'</do-it><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Memory memory accumulator additional_register program_counter zero_result over_flow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'over_flow'</do-it><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	accumulator:=-1.	additional_register:=-1.	program_counter:=-1.	zero_result:=-1.	over_flow:=-1.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter_Interface</class-id> <category>Methods</category><body package="CS474" selector="dec:at:">dec:symbol at:positionself subclassResponsibility.</body></methods><remove-selector><class-id>Interpreter_Interface</class-id> <selector>dec:</selector></remove-selector><remove-selector><class-id>Interpreter</class-id> <selector>dec:</selector></remove-selector><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Interpreter</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Interpreter</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>Interpreter removeFromSystem</do-it><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="lda:">lda:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="xch">xch	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="add">add	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="st:">st:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="dec:at:">dec:symbol at:position	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="hlt">hlt	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldb:">ldb:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jzs:">jzs:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldi:">ldi:value	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jmp:">jmp:number	" *** This method was defined by Interpreter_Interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'memory'</do-it><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory accumulator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'accumulator'</do-it><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory accumulator additional_register </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'additional_register'</do-it><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory accumulator additional_register program_counter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'program_counter'</do-it><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory accumulator additional_register program_counter zero_result </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'zero_result'</do-it><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory accumulator additional_register program_counter zero_result over_flow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'over_flow'</do-it><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	accumulator:=-1.	additional_register:=-1.	program_counter:=-1.	zero_result:=-1.	over_flow:=-1.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="add">add</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="add">add| temp |temp:=accumulator+additional_register.accumulator:=temp.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="dec:at:">dec:symbol at:position</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jmp:">jmp:numberprogram_counter:=number.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:number[over_flow==1]ifTrue:[program_counter:=number.]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jzs:">jzs:number[zero_result==1]ifTrue:[program_counter:=number.]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="lda:">lda:numberaccumulator:=memory at:number.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldb:">ldb:numberadditional_register:=memory at:number.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldi:">ldi:valueaccumulator:=value.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="st:">st:numbermemory at:number put: accumulator.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="xch">xch| temp |temp:=accumulator.accumulator:=additional_register.additional_register:=temp.</body></methods><class><name>Command_interface</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Command_interface</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Command_interface class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>Command_interface organization addCategory: #Methods</do-it><methods><class-id>Command_interface</class-id> <category>Methods</category><body package="CS474" selector="execute">executeself subclassResponsibility.</body></methods><class><name>Dec</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Dec</class-id> <category>accessing</category><body package="CS474" selector="symbol">symbol	^symbol</body></methods><methods><class-id>Dec</class-id> <category>accessing</category><body package="CS474" selector="symbol:">symbol: anObject	symbol := anObject</body></methods><methods><class-id>Dec</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	symbol := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Dec</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><do-it>Dec class organization addCategory: #'instance creation'</do-it><methods><class-id>Dec class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:interpreter_int</body></methods><class><name>Dec</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol interpreter_int </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Dec addInstVarName: 'interpreter_int'</do-it><methods><class-id>Dec</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	interpreter_int:=Interpreter_Interface new.	" *** Edit the following to properly initialize instance variables ***"	symbol := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Dec</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Dec</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>Dec removeFromSystem</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 13, 2018' '11:12:16 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 11:12:16 AM on March 13, 2018."</do-it><class><name>Dec</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Dec</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^Interpreter_int</body></methods><methods><class-id>Dec</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject</body></methods><methods><class-id>Dec</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	Interpreter_int := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Dec</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Dec class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:Interpreter_int_new^super new interpreter_int: Interpreter_int_new.</body></methods><methods><class-id>Dec class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:Interpreter_int_new| temp |temp := super new.temp interpreter_int: Interpreter_int_new.</body></methods><methods><class-id>Dec class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:Interpreter_int_new| temp |temp := super new.temp interpreter_int: Interpreter_int_new.</body></methods><class><name>Dec</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int Symbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Dec</class-id> <category>accessing</category><body package="CS474" selector="symbol">symbol^Symbol.</body></methods><methods><class-id>Dec</class-id> <category>accessing</category><body package="CS474" selector="symbol:">symbol:symSymbol := sym.</body></methods><methods><class-id>Dec class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).</body></methods><methods><class-id>Dec class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp symbol: (params at:2).</body></methods><methods><class-id>Dec</class-id> <category>Methods</category><body package="CS474" selector="execute">executeInterpreter_int dec:Symbol.</body></methods><class><name>Dec</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int Symbol Position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Dec</class-id> <category>Methods</category><body package="CS474" selector="position">position^Position.</body></methods><remove-selector><class-id>Dec</class-id> <selector>position</selector></remove-selector><methods><class-id>Dec</class-id> <category>accessing</category><body package="CS474" selector="position">position^Position.</body></methods><methods><class-id>Dec</class-id> <category>accessing</category><body package="CS474" selector="position:">position:posPosition:=pos.</body></methods><methods><class-id>Dec class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp symbol: (params at:2).temp position: (params at:3).</body></methods><methods><class-id>Dec</class-id> <category>Methods</category><body package="CS474" selector="execute">executeInterpreter_int dec:Symbol at: Position.</body></methods><class><name>Lda</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Lda</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^Interpreter_int</body></methods><methods><class-id>Lda</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject</body></methods><methods><class-id>Lda</class-id> <category>accessing</category><body package="CS474" selector="number">number	^number</body></methods><methods><class-id>Lda</class-id> <category>accessing</category><body package="CS474" selector="number:">number: anObject	number := anObject</body></methods><methods><class-id>Lda</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	Interpreter_int := nil.	number := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Lda</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Lda class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).</body></methods><methods><class-id>Lda</class-id> <category>Methods</category><body package="CS474" selector="execute">executeInterpreter_int lda:Number.</body></methods><class><name>Ldb</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int Number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Ldb</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^Interpreter_int</body></methods><methods><class-id>Ldb</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject</body></methods><methods><class-id>Ldb</class-id> <category>accessing</category><body package="CS474" selector="number">number	^Number</body></methods><methods><class-id>Ldb</class-id> <category>accessing</category><body package="CS474" selector="number:">number: anObject	Number := anObject</body></methods><methods><class-id>Ldb</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	Interpreter_int := nil.	Number := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Ldb</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Ldb class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).</body></methods><methods><class-id>Ldb</class-id> <category>Methods</category><body package="CS474" selector="execute">executeInterpreter_int ldb:Number.</body></methods><class><name>Ldi</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int Value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Ldi</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^Interpreter_int</body></methods><methods><class-id>Ldi</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject</body></methods><methods><class-id>Ldi</class-id> <category>accessing</category><body package="CS474" selector="value">value	^Value</body></methods><methods><class-id>Ldi</class-id> <category>accessing</category><body package="CS474" selector="value:">value: anObject	Value := anObject</body></methods><methods><class-id>Ldi</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	Interpreter_int := nil.	Value := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Ldi</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Ldi class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp value: (params at:1).</body></methods><methods><class-id>Ldi</class-id> <category>Methods</category><body package="CS474" selector="execute">executeInterpreter_int ldi:Value.</body></methods><class><name>St</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int Number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>St</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^Interpreter_int</body></methods><methods><class-id>St</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject</body></methods><methods><class-id>St</class-id> <category>accessing</category><body package="CS474" selector="number">number	^Number</body></methods><methods><class-id>St</class-id> <category>accessing</category><body package="CS474" selector="number:">number: anObject	Number := anObject</body></methods><methods><class-id>St</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	Interpreter_int := nil.	Number := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>St</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>St class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).</body></methods><methods><class-id>St</class-id> <category>Methods</category><body package="CS474" selector="execute">executeInterpreter_int st:Number.</body></methods><class><name>Jmp</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int Number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Jmp</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^Interpreter_int</body></methods><methods><class-id>Jmp</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject</body></methods><methods><class-id>Jmp</class-id> <category>accessing</category><body package="CS474" selector="number">number	^Number</body></methods><methods><class-id>Jmp</class-id> <category>accessing</category><body package="CS474" selector="number:">number: anObject	Number := anObject</body></methods><methods><class-id>Jmp</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	Interpreter_int := nil.	Number := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Jmp</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Jmp class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).</body></methods><methods><class-id>Jmp</class-id> <category>Methods</category><body package="CS474" selector="execute">executeInterpreter_int jmp:Number.</body></methods><class><name>Jzs</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int Number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Jzs</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^Interpreter_int</body></methods><methods><class-id>Jzs</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject</body></methods><methods><class-id>Jzs</class-id> <category>accessing</category><body package="CS474" selector="number">number	^Number</body></methods><methods><class-id>Jzs</class-id> <category>accessing</category><body package="CS474" selector="number:">number: anObject	Number := anObject</body></methods><methods><class-id>Jzs</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	Interpreter_int := nil.	Number := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Jzs</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Jzs class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).</body></methods><methods><class-id>Jzs</class-id> <category>Methods</category><body package="CS474" selector="execute">executeInterpreter_int jzs:Number.</body></methods><class><name>Jvs</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int Number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Jvs</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^Interpreter_int</body></methods><methods><class-id>Jvs</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject</body></methods><methods><class-id>Jvs</class-id> <category>accessing</category><body package="CS474" selector="number">number	^Number</body></methods><methods><class-id>Jvs</class-id> <category>accessing</category><body package="CS474" selector="number:">number: anObject	Number := anObject</body></methods><methods><class-id>Jvs</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	Interpreter_int := nil.	Number := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Jvs</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Jvs class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).</body></methods><methods><class-id>Jvs</class-id> <category>Methods</category><body package="CS474" selector="execute">executeInterpreter_int jvs:Number.</body></methods><class><name>Add</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Add</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^Interpreter_int</body></methods><methods><class-id>Add</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject</body></methods><methods><class-id>Add</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	Interpreter_int := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Add</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Add class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:interpreter_int_new| temp |temp := super new.temp interpreter_int: interpreter_int_new.</body></methods><methods><class-id>Add</class-id> <category>Methods</category><body package="CS474" selector="execute">executeInterpreter_int add.</body></methods><class><name>Hlt</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Interpreter_int </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Hlt</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^Interpreter_int</body></methods><methods><class-id>Hlt</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject</body></methods><methods><class-id>Hlt</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	Interpreter_int := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Hlt</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Hlt class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:interpreter_int_newsuper new interpreter_int: interpreter_int_new.</body></methods><methods><class-id>Hlt</class-id> <category>Methods</category><body package="CS474" selector="execute">executeInterpreter_int hlt.</body></methods><class><name>TheCommand</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Command_int </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>TheCommand</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>TheCommand</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>TheCommand removeFromSystem</do-it><class><name>TheCommand</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Command_int </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>TheCommand</class-id> <category>accessing</category><body package="CS474" selector="command_int">command_int	^Command_int</body></methods><methods><class-id>TheCommand</class-id> <category>accessing</category><body package="CS474" selector="command_int:">command_int: anObject	Command_int := anObject</body></methods><methods><class-id>TheCommand</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	Command_int := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>TheCommand class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>TheCommand class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:command_int_new| temp |temp := super new.temp command_int: command_int_new.</body></methods><remove-selector><class-id>TheCommand class</class-id> <selector>new</selector></remove-selector><do-it>TheCommand organization addCategory: #Methods</do-it><methods><class-id>TheCommand</class-id> <category>Methods</category><body package="CS474" selector="run">run</body></methods><methods><class-id>TheCommand</class-id> <category>Methods</category><body package="CS474" selector="run">runCommand_int execute.</body></methods><class><name>ALI</name><environment>Smalltalk</environment><super>TheCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interpreter_int command run_command </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>ALI</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^interpreter_int</body></methods><methods><class-id>ALI</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	interpreter_int := anObject</body></methods><methods><class-id>ALI</class-id> <category>accessing</category><body package="CS474" selector="command">command	^command</body></methods><methods><class-id>ALI</class-id> <category>accessing</category><body package="CS474" selector="command:">command: anObject	command := anObject</body></methods><methods><class-id>ALI</class-id> <category>accessing</category><body package="CS474" selector="run_command">run_command	^run_command</body></methods><methods><class-id>ALI</class-id> <category>accessing</category><body package="CS474" selector="run_command:">run_command: anObject	run_command := anObject</body></methods><methods><class-id>ALI</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	interpreter_int := nil.	command := nil.	run_command := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>ALI class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><class><name>ALI</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interpreter_int command run_command </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ALI</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ALI</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>ALI removeFromSystem</do-it><do-it>interpreter_int := Interpreter_Interface new.</do-it><do-it>interpreter_int := Interpreter new.</do-it><do-it>interpreter_int := Interpreter new.hltcommand := Hlt new:interpreter_int.onRun := TheCommand new:hltcommand.</do-it><do-it>onRun class.</do-it><do-it>onRun superclass.</do-it><do-it>onRun.</do-it><methods><class-id>TheCommand</class-id> <category>Methods</category><body package="CS474" selector="run">run| temp |temp :='abc'."Command_int execute."^temp.</body></methods><do-it>interpreter_int := Interpreter new.hltcommand := Hlt new:interpreter_int.onRun := TheCommand new:hltcommand.</do-it><do-it>interpreter_int := Interpreter_Interface new.hltcommand := Command_interface new.onRun := TheCommand new:hltcommand.</do-it><do-it>interpreter_int := Interpreter new.hltcommand := Hlt new:interpreter_int.onRun := TheCommand new:hltcommand.</do-it><do-it>interpreter_int := Interpreter new.hltcommand := Hlt new:interpreter_int.onRun := TheCommand new:hltcommand.</do-it><do-it>onRun</do-it><do-it>onRun</do-it><do-it>onRun methodDictionary.</do-it><do-it>hltcommand methodDictionary.</do-it><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="hlt">hlt^'abc'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="dec:at:">dec:symbol at:position^'abc'</body></methods><do-it>interpreter_int := Interpreter_Interface new.</do-it><do-it>interpreter_int := Interpreter_Interface new.hltcommand := Hlt new:interpreter_int.onRun := TheCommand new:hltcommand.</do-it><do-it>| interpreter |interpreter_int := Interpreter_Interface new.interpreter := Interpreter new.interpreter_int := interpreter.hltcommand := Hlt new:interpreter_int.onRun := TheCommand new:hltcommand.</do-it><do-it>interpreter := Interpreter new.interpreter hlt.</do-it><methods><class-id>Hlt class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:interpreter_int_newsuper new interpreter_int: interpreter_int_new.^'abc'</body></methods><do-it>interpreter_int := Interpreter_Interface new.interpreter := Interpreter new.interpreter_int := interpreter.hltcommand := Hlt new:interpreter_int.</do-it><methods><class-id>Hlt class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:interpreter_int_newsuper new interpreter_int: interpreter_int_new.</body></methods><methods><class-id>Hlt</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject.	^'abc'</body></methods><methods><class-id>Hlt class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:interpreter_int_new^super new interpreter_int: interpreter_int_new.</body></methods><do-it>interpreter_int := Interpreter_Interface new.interpreter := Interpreter new.interpreter_int := interpreter.hltcommand := Hlt new:interpreter_int.</do-it><methods><class-id>Hlt</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	Interpreter_int := anObject.</body></methods><do-it>| interpreter_inter| interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.</do-it><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.</do-it><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.</do-it><methods><class-id>TheCommand class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:command_int_new| temp |temp := super new.temp command_int: command_int_new.^'abc'</body></methods><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.</do-it><methods><class-id>TheCommand class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:command_int_new| temp |temp := super new.temp command_int: command_int_new.</body></methods><methods><class-id>TheCommand class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:command_int_new| temp |temp := super new.temp command_int: command_int_new.^'abc'</body></methods><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.</do-it><methods><class-id>TheCommand class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:command_int_new| temp |temp := super new.temp command_int: command_int_new.</body></methods><methods><class-id>TheCommand</class-id> <category>Methods</category><body package="CS474" selector="run">run| temp |temp :='abc'.^temp.</body></methods><methods><class-id>TheCommand</class-id> <category>Methods</category><body package="CS474" selector="run">run^'abc'</body></methods><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.</do-it><do-it>onRun class.</do-it><do-it>onRun superclass.</do-it><do-it>onRun methodDictionary.</do-it><methods><class-id>TheCommand</class-id> <category>Methods</category><body package="CS474" selector="interprete">interprete^'abc'</body></methods><remove-selector><class-id>TheCommand</class-id> <selector>run</selector></remove-selector><remove-selector><class-id>TheCommand</class-id> <selector>interprete</selector></remove-selector><do-it>TheCommand organization removeCategory: #Methods</do-it><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.</do-it><methods><class-id>TheCommand class</class-id> <category>instance creation</category><body package="CS474" selector="new">new^super new initialize.</body></methods><remove-selector><class-id>TheCommand class</class-id> <selector>new:</selector></remove-selector><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new.</do-it><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new.onRun command_int.</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 14, 2018' '5:58:46 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 5:58:46 AM on March 14, 2018."</do-it><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new.onRun command_int.</do-it><methods><class-id>TheCommand class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:command_int_new| temp |temp := super new.temp command_int: command_int_new.</body></methods><remove-selector><class-id>TheCommand class</class-id> <selector>new</selector></remove-selector><do-it>TheCommand organization addCategory: #Methods</do-it><methods><class-id>TheCommand</class-id> <category>Methods</category><body package="CS474" selector="press">press Command_int execute.</body></methods><methods><class-id>TheCommand class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:command_int_new| temp |temp := super new.temp command_int: command_int_new.^'abc'</body></methods><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.</do-it><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.</do-it><do-it>interpreter_inter := Interpreter_Interface new.</do-it><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.</do-it><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.</do-it><methods><class-id>TheCommand</class-id> <category>Methods</category><body package="CS474" selector="press">press^'abc'</body></methods><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.</do-it><methods><class-id>TheCommand class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:command_int_newsuper new command_int: command_int_new.^'abc'</body></methods><methods><class-id>TheCommand class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:command_int_new^super new command_int: command_int_new.</body></methods><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.</do-it><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.</do-it><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.onRun press.</do-it><methods><class-id>TheCommand</class-id> <category>Methods</category><body package="CS474" selector="press">pressCommand_int execute.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="hlt">hlt^'halted'</body></methods><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.onRun press.</do-it><methods><class-id>TheCommand</class-id> <category>Methods</category><body package="CS474" selector="press">pressCommand_int execute.</body></methods><methods><class-id>Add class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:interpreter_int_new| temp |temp := super new.temp interpreter_int: interpreter_int_new.^temp.</body></methods><methods><class-id>Dec class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp symbol: (params at:2).temp position: (params at:3).^temp</body></methods><methods><class-id>Jmp class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).^temp</body></methods><methods><class-id>Jvs class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).^temp</body></methods><methods><class-id>Jzs class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).^temp</body></methods><methods><class-id>Lda class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).^temp</body></methods><methods><class-id>Ldb class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).^temp</body></methods><methods><class-id>Ldi class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp value: (params at:1).^temp</body></methods><methods><class-id>St class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:1).^temp</body></methods><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.onRun press.</do-it><methods><class-id>Hlt</class-id> <category>Methods</category><body package="CS474" selector="execute">execute^Interpreter_int hlt.</body></methods><methods><class-id>TheCommand</class-id> <category>Methods</category><body package="CS474" selector="press">press^Command_int execute.</body></methods><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.onRun press.</do-it><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.hltcommand interpreter_int.onRun := TheCommand new:hltcommand.onRun press.</do-it><methods><class-id>Add</class-id> <category>Methods</category><body package="CS474" selector="execute">execute^Interpreter_int add.</body></methods><methods><class-id>Dec</class-id> <category>Methods</category><body package="CS474" selector="execute">execute^Interpreter_int dec:Symbol at: Position.</body></methods><methods><class-id>Jmp</class-id> <category>Methods</category><body package="CS474" selector="execute">execute^Interpreter_int jmp:Number.</body></methods><methods><class-id>Jvs</class-id> <category>Methods</category><body package="CS474" selector="execute">execute^Interpreter_int jvs:Number.</body></methods><methods><class-id>Jzs</class-id> <category>Methods</category><body package="CS474" selector="execute">execute^Interpreter_int jzs:Number.</body></methods><methods><class-id>Lda</class-id> <category>Methods</category><body package="CS474" selector="execute">execute^Interpreter_int lda:Number.</body></methods><methods><class-id>Ldb</class-id> <category>Methods</category><body package="CS474" selector="execute">execute^Interpreter_int ldb:Number.</body></methods><methods><class-id>Ldi</class-id> <category>Methods</category><body package="CS474" selector="execute">execute^Interpreter_int ldi:Value.</body></methods><methods><class-id>St</class-id> <category>Methods</category><body package="CS474" selector="execute">execute^Interpreter_int st:Number.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="add">add| temp |temp:=accumulator+additional_register.accumulator:=temp.^accumulator.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldi:">ldi:valueaccumulator:=value.^accumulator</body></methods><do-it>params1 := OrderedCollection new.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.onRun := TheCommand new:hltcommand.onRun press.params1 add:interpreter_inter.params1 add:10.ldicmd := Ldi new:params1.onRun := TheCommand new:ldicmd.onRun press.</do-it><do-it>params1 := OrderedCollection new.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.onRun := TheCommand new:hltcommand.onRun press.params1 add:interpreter_inter.params1 add:10.ldicmd := Ldi new:params1.onRun := TheCommand new:ldicmd.onRun press.</do-it><methods><class-id>Ldi class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp value: (params at:2).^temp</body></methods><do-it>params1 := OrderedCollection new.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.onRun := TheCommand new:hltcommand.onRun press.params1 add:interpreter_inter.params1 add:10.ldicmd := Ldi new:params1.onRun := TheCommand new:ldicmd.onRun press.</do-it><do-it>params1 := OrderedCollection new.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.hltcommand := Hlt new:interpreter_inter.onRun := TheCommand new:hltcommand.onRun press.params1 add:interpreter_inter.params1 add:10.ldicmd := Ldi new:params1.onRun := TheCommand new:ldicmd.onRun press.addcmd := Add new:interpreter_inter.onRun := TheCommand new:addcmd.onRun press.</do-it><methods><class-id>Ldb class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:2).^temp</body></methods><methods><class-id>St class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:2).^temp</body></methods><methods><class-id>Lda class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:2).^temp</body></methods><methods><class-id>Jzs class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:2).^temp</body></methods><methods><class-id>Jvs class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:2).^temp</body></methods><methods><class-id>Jmp class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:params| temp |temp := super new.temp interpreter_int: (params at:1).temp number: (params at:2).^temp</body></methods><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	accumulator:=-1.	additional_register:=-1.	program_counter:=-1.	zero_result:=-1.	over_flow:=0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	accumulator:=-1.	additional_register:=-1.	program_counter:=-1.	zero_result:=0.	over_flow:=0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	accumulator:=-1.	additional_register:=-1.	program_counter:=0.	zero_result:=0.	over_flow:=0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	accumulator:=0.	additional_register:=0.	program_counter:=0.	zero_result:=0.	over_flow:=0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory accumulator additional_register program_counter zero_result over_flow opcode_array </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'opcode_array'</do-it><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	opcode_array := Dictionary new.	accumulator:=0.	additional_register:=0.	program_counter:=0.	zero_result:=0.	over_flow:=0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	opcode_array := Dictionary new.	opcode_array at:'add' put: 1.	opcode_array at:'dec' put: 2.	opcode_array at:'hlt' put: 3.	opcode_array at:'jmp' put: 4.	opcode_array at:'jvs' put: 5.	opcode_array at:'jzs' put: 6.	opcode_array at:'lda' put: 7.	opcode_array at:'ldb' put: 8.	opcode_array at:'ldi' put: 9.	opcode_array at:'st' put: 10.	opcode_array at:'xch' put: 11.	accumulator:=0.	additional_register:=0.	program_counter:=0.	zero_result:=0.	over_flow:=0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory accumulator additional_register program_counter zero_result over_flow opcode_array symbol_dict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Interpreter addInstVarName: 'symbol_dict'</do-it><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	opcode_array := Dictionary new.	opcode_array at:'add' put: 1.	opcode_array at:'dec' put: 2.	opcode_array at:'hlt' put: 3.	opcode_array at:'jmp' put: 4.	opcode_array at:'jvs' put: 5.	opcode_array at:'jzs' put: 6.	opcode_array at:'lda' put: 7.	opcode_array at:'ldb' put: 8.	opcode_array at:'ldi' put: 9.	opcode_array at:'st' put: 10.	opcode_array at:'xch' put: 11.	symbol_dict := Dictionary new.	accumulator:=0.	additional_register:=0.	program_counter:=0.	zero_result:=0.	over_flow:=0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="dec:at:">dec:symbol at:position^'abc'</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="dec:at:">dec:symbol at:position^'abc'</body></methods><methods><class-id>Interpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Interpreter' 			#bounds: #(#{Graphics.Rectangle} 540 240 740 440 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 62 0 37 0 ) 					#name: #Label1 					#label: 'HelloWorld' ) ) ) )</body></methods><remove-selector><class-id>Interpreter class</class-id> <selector>windowSpec</selector></remove-selector><do-it>Interpreter class organization removeCategory: #'interface specs'</do-it><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>TheCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'InterpreterWindow' 			#bounds: #(#{Graphics.Rectangle} 221 31 1038 679 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 50 0 29 0 790 0 267 0 ) 					#name: #TextEditor1 					#model: #ProgramText 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 170 0 288 0 322 0 309 0 ) 					#name: #ActionButton1 					#model: #ExecuteCurrentLine 					#label: 'Execute Current Line' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 513 0 288 0 687 0 309 0 ) 					#name: #ActionButton2 					#model: #ExecuteCompleteProgram 					#label: 'Execute Complete Program' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 407 0 368 0 ) 					#name: #Label1 					#label: 'State of the regesters' ) ) ) )</body></methods><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ProgramText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #MainInterpreter	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: ' ProgramText '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="ProgramText">ProgramText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^ProgramText isNil		ifTrue:			[ProgramText := String new asValue]		ifFalse:			[ProgramText]</body></methods><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'InterpreterWindow' 			#bounds: #(#{Graphics.Rectangle} 232 31 1049 679 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 170 0 288 0 322 0 309 0 ) 					#name: #ActionButton1 					#model: #ExecuteCurrentLine 					#label: 'Execute Current Line' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 513 0 288 0 687 0 309 0 ) 					#name: #ActionButton2 					#model: #ExecuteCompleteProgram 					#label: 'Execute Complete Program' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 407 0 368 0 ) 					#name: #Label1 					#label: 'State of the regesters' ) ) ) )</body></methods><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ProgramText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #MainInterpreter	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'ProgramText  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><remove-selector><class-id>MainInterpreter class</class-id> <selector>windowSpec</selector></remove-selector><do-it>MainInterpreter class organization removeCategory: #'interface specs'</do-it><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Interpreter' 			#bounds: #(#{Graphics.Rectangle} 540 240 740 440 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 23 0 ) 					#name: #Label1 					#label: 'States of the Registers' ) ) ) )</body></methods><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Interpreter' 			#bounds: #(#{Graphics.Rectangle} 698 245 1090 549 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 73 0 23 0 ) 					#name: #Label1 					#label: 'States of the Registers' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 19 0 56 0 ) 					#name: #Label2 					#label: 'Accumalator' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 19 0 83 0 ) 					#name: #Label3 					#label: 'Additional Register' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 19 0 110 0 ) 					#name: #Label4 					#label: 'Program Counter' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 19 0 137 0 ) 					#name: #Label5 					#label: 'Overflow' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 19 0 164 0 ) 					#name: #Label6 					#label: 'Zero Result' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 141 0 55 0 241 0 74 0 ) 					#name: #InputField1 					#model: #Accumalator ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 141 0 82 0 241 0 101 0 ) 					#name: #InputField2 					#model: #Additional_Register ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 141 0 109 0 241 0 128 0 ) 					#name: #InputField3 					#model: #Program_Counter ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 141 0 136 0 241 0 155 0 ) 					#name: #InputField4 					#model: #Overflow ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 141 0 163 0 241 0 182 0 ) 					#name: #InputField5 					#model: #Zero_Result ) ) ) )</body></methods><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ProgramText Program_Counter Overflow Additional_Register Zero_Result Accumalator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #MainInterpreter	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'ProgramText  Program_Counter Overflow Additional_Register Zero_Result Accumalator '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Program_Counter">Program_Counter	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Program_Counter isNil		ifTrue:			[Program_Counter := String new asValue]		ifFalse:			[Program_Counter]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Overflow">Overflow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Overflow isNil		ifTrue:			[Overflow := String new asValue]		ifFalse:			[Overflow]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Additional_Register">Additional_Register	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Additional_Register isNil		ifTrue:			[Additional_Register := String new asValue]		ifFalse:			[Additional_Register]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Zero_Result">Zero_Result	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Zero_Result isNil		ifTrue:			[Zero_Result := String new asValue]		ifFalse:			[Zero_Result]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Accumalator">Accumalator	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Accumalator isNil		ifTrue:			[Accumalator := String new asValue]		ifFalse:			[Accumalator]</body></methods><remove-selector><class-id>MainInterpreter</class-id> <selector>ExecuteCurrentLine</selector></remove-selector><remove-selector><class-id>MainInterpreter</class-id> <selector>ExecuteCompleteProgram</selector></remove-selector><do-it>MainInterpreter organization removeCategory: #actions</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 17, 2018' '11:56:02 PM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 11:56:02 PM on March 17, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 17, 2018' '11:56:06 PM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 11:56:06 PM on March 17, 2018."</do-it><methods><class-id>Interpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'TestCanvas' 			#bounds: #(#{Graphics.Rectangle} 540 240 740 440 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 79 0 25 0 ) 					#name: #Label1 					#label: 'HelloWorld' ) ) ) )</body></methods><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MainInterpreter' 			#bounds: #(#{Graphics.Rectangle} 444 188 836 492 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 73 0 23 0 ) 					#name: #Label1 					#label: 'States of the Registers' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 19 0 56 0 ) 					#name: #Label2 					#label: 'Accumalator' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 19 0 83 0 ) 					#name: #Label3 					#label: 'Additional Register' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 19 0 110 0 ) 					#name: #Label4 					#label: 'Program Counter' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 19 0 137 0 ) 					#name: #Label5 					#label: 'Overflow' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 19 0 164 0 ) 					#name: #Label6 					#label: 'Zero Result' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 141 0 55 0 241 0 74 0 ) 					#name: #InputField1 					#model: #Accumalator ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 141 0 82 0 241 0 101 0 ) 					#name: #InputField2 					#model: #Additional_Register ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 141 0 109 0 241 0 128 0 ) 					#name: #InputField3 					#model: #Program_Counter ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 141 0 136 0 241 0 155 0 ) 					#name: #InputField4 					#model: #Overflow ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 141 0 163 0 241 0 182 0 ) 					#name: #InputField5 					#model: #Zero_Result ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 18, 2018' '12:01:21 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 12:01:21 AM on March 18, 2018."</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>MainInterpreter</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>MainInterpreter</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>MainInterpreter removeFromSystem</do-it><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MainInterpreter' 			#bounds: #(#{Graphics.Rectangle} 488 78 1251 559 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 317 0 262 0 ) 					#name: #Label1 					#label: 'State''s of the registers' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 257 0 305 0 ) 					#name: #Label2 					#label: 'Accumulator' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 257 0 337 0 ) 					#name: #Label3 					#label: 'Additional Register' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 257 0 369 0 ) 					#name: #Label4 					#label: 'Program Counter' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 257 0 401 0 ) 					#name: #Label5 					#label: 'Zero Result' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 257 0 433 0 ) 					#name: #Label6 					#label: 'Overflow' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 430 0 301 0 530 0 320 0 ) 					#name: #InputField1 					#model: #Accumulator ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 430 0 334 0 530 0 353 0 ) 					#name: #InputField2 					#model: #Additional_Register ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 430 0 367 0 530 0 386 0 ) 					#name: #InputField3 					#model: #Program_Counter ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 430 0 400 0 530 0 419 0 ) 					#name: #InputField4 					#model: #Zero_Result ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 430 0 433 0 530 0 452 0 ) 					#name: #InputField5 					#model: #Overflow ) ) ) )</body></methods><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Accumulator Program_Counter Zero_Result Additional_Register Overflow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #MainInterpreter	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: ' Accumulator Program_Counter Zero_Result Additional_Register Overflow '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Accumulator">Accumulator	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Accumulator isNil		ifTrue:			[Accumulator := String new asValue]		ifFalse:			[Accumulator]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Program_Counter">Program_Counter	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Program_Counter isNil		ifTrue:			[Program_Counter := String new asValue]		ifFalse:			[Program_Counter]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Zero_Result">Zero_Result	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Zero_Result isNil		ifTrue:			[Zero_Result := String new asValue]		ifFalse:			[Zero_Result]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Additional_Register">Additional_Register	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Additional_Register isNil		ifTrue:			[Additional_Register := String new asValue]		ifFalse:			[Additional_Register]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Overflow">Overflow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Overflow isNil		ifTrue:			[Overflow := String new asValue]		ifFalse:			[Overflow]</body></methods><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MainInterpreter' 			#bounds: #(#{Graphics.Rectangle} 488 78 1251 559 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 301 0 284 0 ) 					#name: #Label1 					#label: 'State''s of the registers' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 327 0 ) 					#name: #Label2 					#label: 'Accumulator' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 359 0 ) 					#name: #Label3 					#label: 'Additional Register' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 391 0 ) 					#name: #Label4 					#label: 'Program Counter' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 423 0 ) 					#name: #Label5 					#label: 'Zero Result' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 455 0 ) 					#name: #Label6 					#label: 'Overflow' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 323 0 514 0 342 0 ) 					#name: #InputField1 					#model: #Accumulator ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 356 0 514 0 375 0 ) 					#name: #InputField2 					#model: #Additional_Register ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 389 0 514 0 408 0 ) 					#name: #InputField3 					#model: #Program_Counter ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 422 0 514 0 441 0 ) 					#name: #InputField4 					#model: #Zero_Result ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 455 0 514 0 474 0 ) 					#name: #InputField5 					#model: #Overflow ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 193 0 27 0 551 0 223 0 ) 					#name: #TextEditor1 					#model: #Program_Text 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 152 0 245 0 317 0 266 0 ) 					#name: #ActionButton1 					#model: #ExecuteCurrentLine 					#label: 'Execute Current Line' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 430 0 245 0 595 0 266 0 ) 					#name: #ActionButton2 					#model: #ExecuteCompleteProgram 					#label: 'Execute Complete Program' 					#defaultable: true ) ) ) )</body></methods><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Accumulator Program_Counter Zero_Result Additional_Register Overflow Program_Text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #MainInterpreter	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'Accumulator Program_Counter Zero_Result Additional_Register Overflow  Program_Text '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Accumulator">Accumulator	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Accumulator isNil		ifTrue:			[Accumulator := String new asValue]		ifFalse:			[Accumulator]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Program_Counter">Program_Counter	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Program_Counter isNil		ifTrue:			[Program_Counter := String new asValue]		ifFalse:			[Program_Counter]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Zero_Result">Zero_Result	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Zero_Result isNil		ifTrue:			[Zero_Result := String new asValue]		ifFalse:			[Zero_Result]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Overflow">Overflow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Overflow isNil		ifTrue:			[Overflow := String new asValue]		ifFalse:			[Overflow]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Program_Text">Program_Text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Program_Text isNil		ifTrue:			[Program_Text := String new asValue]		ifFalse:			[Program_Text]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Additional_Register">Additional_Register	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Additional_Register isNil		ifTrue:			[Additional_Register := String new asValue]		ifFalse:			[Additional_Register]</body></methods><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MainInterpreter' 			#bounds: #(#{Graphics.Rectangle} 488 78 1251 559 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 301 0 284 0 ) 					#name: #Label1 					#label: 'State''s of the registers' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 327 0 ) 					#name: #Label2 					#label: 'Accumulator' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 359 0 ) 					#name: #Label3 					#label: 'Additional Register' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 391 0 ) 					#name: #Label4 					#label: 'Program Counter' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 423 0 ) 					#name: #Label5 					#label: 'Zero Result' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 455 0 ) 					#name: #Label6 					#label: 'Overflow' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 323 0 514 0 342 0 ) 					#name: #InputField1 					#model: #Accumulator ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 356 0 514 0 375 0 ) 					#name: #InputField2 					#model: #Additional_Register ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 389 0 514 0 408 0 ) 					#name: #InputField3 					#model: #Program_Counter ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 422 0 514 0 441 0 ) 					#name: #InputField4 					#model: #Zero_Result ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 455 0 514 0 474 0 ) 					#name: #InputField5 					#model: #Overflow ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 193 0 27 0 551 0 223 0 ) 					#name: #TextEditor1 					#model: #Program_Text 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 152 0 245 0 317 0 266 0 ) 					#name: #ActionButton1 					#model: #ExecuteCurrentLine 					#label: 'Execute Current Line' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 430 0 245 0 595 0 266 0 ) 					#name: #ActionButton2 					#model: #ExecuteCompleteProgram 					#label: 'Execute Complete Program' 					#defaultable: true ) ) ) )</body></methods><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Accumulator Program_Counter Zero_Result Additional_Register Overflow Program_Text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #MainInterpreter	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'Accumulator Program_Counter Zero_Result Additional_Register Overflow Program_Text  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MainInterpreter' 			#bounds: #(#{Graphics.Rectangle} 488 78 1251 559 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 301 0 284 0 ) 					#name: #Label1 					#label: 'State''s of the registers' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 327 0 ) 					#name: #Label2 					#label: 'Accumulator' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 359 0 ) 					#name: #Label3 					#label: 'Additional Register' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 391 0 ) 					#name: #Label4 					#label: 'Program Counter' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 423 0 ) 					#name: #Label5 					#label: 'Zero Result' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 455 0 ) 					#name: #Label6 					#label: 'Overflow' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 323 0 514 0 342 0 ) 					#name: #InputField1 					#model: #Accumulator ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 356 0 514 0 375 0 ) 					#name: #InputField2 					#model: #Additional_Register ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 389 0 514 0 408 0 ) 					#name: #InputField3 					#model: #Program_Counter ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 422 0 514 0 441 0 ) 					#name: #InputField4 					#model: #Zero_Result ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 455 0 514 0 474 0 ) 					#name: #InputField5 					#model: #Overflow ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 193 0 27 0 551 0 223 0 ) 					#name: #TextEditor1 					#model: #Program_Text 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 152 0 245 0 317 0 266 0 ) 					#name: #ActionButton1 					#model: #ExecuteCurrentLine 					#label: 'Execute Current Line' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 430 0 245 0 595 0 266 0 ) 					#name: #ActionButton2 					#model: #ExecuteCompleteProgram 					#label: 'Execute Complete Program' 					#defaultable: true ) ) ) )</body></methods><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Accumulator Program_Counter Zero_Result Additional_Register Overflow Program_Text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #MainInterpreter	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'Accumulator Program_Counter Zero_Result Additional_Register Overflow Program_Text  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Accumulator">Accumulator	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Accumulator isNil		ifTrue:			[Accumulator := String new asValue]		ifFalse:			[Accumulator]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Program_Counter">Program_Counter	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Program_Counter isNil		ifTrue:			[Program_Counter := String new asValue]		ifFalse:			[Program_Counter]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Zero_Result">Zero_Result	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Zero_Result isNil		ifTrue:			[Zero_Result := String new asValue]		ifFalse:			[Zero_Result]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Overflow">Overflow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Overflow isNil		ifTrue:			[Overflow := String new asValue]		ifFalse:			[Overflow]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Program_Text">Program_Text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Program_Text isNil		ifTrue:			[Program_Text := String new asValue]		ifFalse:			[Program_Text]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Additional_Register">Additional_Register	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Additional_Register isNil		ifTrue:			[Additional_Register := String new asValue]		ifFalse:			[Additional_Register]</body></methods><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MainInterpreter' 			#bounds: #(#{Graphics.Rectangle} 488 78 1251 559 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 301 0 284 0 ) 					#name: #Label1 					#label: 'State''s of the registers' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 327 0 ) 					#name: #Label2 					#label: 'Accumulator :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 359 0 ) 					#name: #Label3 					#label: 'Additional Register :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 391 0 ) 					#name: #Label4 					#label: 'Program Counter :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 423 0 ) 					#name: #Label5 					#label: 'Zero Result :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 241 0 455 0 ) 					#name: #Label6 					#label: 'Overflow :' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 193 0 27 0 551 0 223 0 ) 					#name: #TextEditor1 					#model: #Program_Text 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 152 0 245 0 317 0 266 0 ) 					#name: #ActionButton1 					#model: #ExecuteCurrentLine 					#label: 'Execute Current Line' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 430 0 245 0 595 0 266 0 ) 					#name: #ActionButton2 					#model: #ExecuteCompleteProgram 					#label: 'Execute Complete Program' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 377 0 328 0 ) 					#name: #Label7 					#label: 'nil' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 377 0 360 0 ) 					#name: #Label8 					#label: 'nil' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 377 0 392 0 ) 					#name: #Label9 					#label: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 377 0 424 0 ) 					#name: #Label10 					#label: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 377 0 456 0 ) 					#name: #Label11 					#label: '0' ) ) ) )</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.Transcript show: program.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.1 to: program size do:[:x|[program at:x ~= '\n']ifTrue:[Transcript show: (program at:x)]].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.1 to: program size do:[:x|(program at:x ~= '\n')ifTrue:[Transcript show: (program at:x)]].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.Transcript show: program size."1 to: program size do:[:x|(program at:x ~= '\n')ifTrue:[Transcript show: (program at:x)]]."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.Transcript show: program class."1 to: program size do:[:x|(program at:x ~= '\n')ifTrue:[Transcript show: (program at:x)]]."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.Transcript show: (program class) asString."1 to: program size do:[:x|(program at:x ~= '\n')ifTrue:[Transcript show: (program at:x)]]."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.Transcript show: (program class) printString."1 to: program size do:[:x|(program at:x ~= '\n')ifTrue:[Transcript show: (program at:x)]]."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.Transcript show: (program size) printString."1 to: program size do:[:x|(program at:x ~= '\n')ifTrue:[Transcript show: (program at:x)]]."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.1 to: program size do:[:x|(program at:x ~= '\n')ifTrue:[Transcript show: (program at:x) printString]].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.Transcript show: (program at:10)."1 to: program size do:[:x|(program at:x ~= '\n')ifTrue:[Transcript show: (program at:x) printString]]."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.Transcript show: (program at:10) printString."1 to: program size do:[:x|(program at:x ~= '\n')ifTrue:[Transcript show: (program at:x) printString]]."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value."Transcript show: (program at:10) printString."1 to: program size do:[:x|(program at:x ~= '\n')ifTrue:[Transcript show: ((program at:x) printString)]].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value."Transcript show: (program at:10) printString."1 to: program size by:1 do:[:x|(program at:x ~= '\n')ifTrue:[Transcript show: ((program at:x) printString)]].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value."Transcript show: (program at:10) printString."1 to: program size by:1 do:[:x|(program at:x ~~ '\n')ifTrue:[Transcript show: ((program at:x) printString)]].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.Transcript show: (program at:18) printString."1 to: program size by:1 do:[:x|(program at:x ~~ '\n')ifTrue:[Transcript show: ((program at:x) printString)]]."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.Transcript show: (program at:18) printString.1 to: program size by:1 do:[:x|(program at:x ~= Core.Character cr)ifTrue:[Transcript show: ((program at:x) printString)]].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.Transcript show: (program at:18) printString.1 to: program size by:1 do:[:x|(program at:x ~~ Core.Character cr)ifTrue:[Transcript show: ((program at:x) printString)]].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.(program at:10 ~~ Core.Character cr)ifTrue:[Transcript show: ((program at:10) printString)]."1 to: program size do:[:x|(program at:x ~~ Core.Character cr)ifTrue:[Transcript show: ((program at:x) printString)]]."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.(program at:10 ~~ Character cr)ifTrue:[Transcript show: ((program at:10) printString)]."1 to: program size do:[:x|(program at:x ~~ Core.Character cr)ifTrue:[Transcript show: ((program at:x) printString)]]."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.((program at:10) ~~ (Character cr))ifTrue:[Transcript show: ((program at:10) printString)]."1 to: program size do:[:x|(program at:x ~~ Core.Character cr)ifTrue:[Transcript show: ((program at:x) printString)]]."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value."((program at:10) ~~ (Character cr))ifTrue:[Transcript show: ((program at:10) printString)]."1 to: program size do:[:x|((program at:x) ~~ Character cr)ifTrue:[Transcript show: ((program at:x) printString)]].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value."((program at:10) ~~ (Character cr))ifTrue:[Transcript show: ((program at:10) printString)]."1 to: program size do:[:x|((program at:x) ~~ Character cr)ifTrue:[Transcript show: ((program at:x))]].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr |interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.tempstr:=''.1 to: program size do:[:x|	((program at:x) ~~ Character cr)ifTrue:[		tempstr=tempstr+(program at:x).		]	].Transcript show: tempstr printString.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr |interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.tempstr:=''.1 to: program size do:[:x|	((program at:x) ~~ Character cr)ifTrue:[		tempstr=tempstr,(program at:x).		]	].Transcript show: tempstr printString.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr |interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.tempstr:=''.1 to: program size do:[:x|	((program at:x) ~~ Character cr)ifTrue:[		tempstr:=tempstr,(program at:x).		]	].Transcript show: tempstr printString.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr temp|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.tempstr:=''.1 to: program size do:[:x|	((program at:x) == Character cr)ifTrue:[		temp := x.		]	].tempstr copyFrom: 1 to: temp.Transcript show: tempstr printString.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr temp|interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.tempstr:=''.1 to: program size do:[:x|	((program at:x) == Character cr)ifTrue:[		temp := x.		]	].tempstr copyFrom: 1 to: temp.Transcript show: tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr len temp|len := 1.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) == (Character cr))ifTrue:[temp := (len - 1)].	len:=len+1.	].tempstr copyFrom: 1 to: temp.Transcript show: tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr len temp|tempstr := ''.len := 1.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) == (Character cr))ifTrue:[temp := (len - 1)].	len:=len+1.	].tempstr copyFrom: 1 to: temp.Transcript show: tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr len temp|tempstr := ''.len := 1.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) == (Character cr))ifTrue:[temp := (len - 1)].	len:=len+1.	].tempstr copyFrom: 1 to: temp.Transcript show: tempstr printString.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr len temp|tempstr := ''.len := 1.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifTrue:[tempstr := tempstr,(program at:len)].	len:=len+1.	].Transcript show: tempstr printString.^self.</body></methods><do-it>temp := 'abcd'.(temp at:2) class.</do-it><do-it>temp := 'abcd'.((temp at:2) printString) class.</do-it><do-it>temp := 'abcd'.temp class.</do-it><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr len temp|tempstr := ''.len := 1.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifTrue:[tempstr := (tempstr,(program at:len))].	len:=len+1.	].Transcript show: tempstr printString.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr len temp|tempstr := ''.len := 1.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifTrue:[tempstr := (tempstr,((program at:len) printString))].	len:=len+1.	].Transcript show: tempstr printString.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| interpreter_inter interpreter program 	tempstr len temp|tempstr := ''.len := 1.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifTrue:[tempstr := (tempstr,((program at:len) printString))].	len:=len+1.	].Transcript show: tempstr.^self.</body></methods><do-it>MainInterpreter organization addCategory: #Methods</do-it><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory| interpreter_inter interpreter program 	tempstr len temp|tempstr := ''.len := 1.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifTrue:[tempstr := (tempstr,((program at:len) printString))].	len:=len+1.	].Transcript show: tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory| interpreter_inter interpreter program 	tempstr len temp|tempstr := ''.len := 1.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifTrue:[tempstr := (tempstr,((program at:len) printString))].	len:=len+1.	].Transcript show: tempstr.^self.</body></methods><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Accumulator Program_Counter Zero_Result Additional_Register Overflow Program_Text interpreter_interface interpreter program </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	interpreter_interface := Interpreter_Interface new.	interpreter := Interpreter new.	interpreter_interface := interpreter.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp|tempstr := ''.len := 1.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifTrue:[tempstr := (tempstr,((program at:len) printString))].	len:=len+1.	].Transcript show: tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp|tempstr := ''.len := 1.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifTrue:[tempstr := (tempstr,((program at:len) printString))]								ifFalse:[].	len:=len+1.	].Transcript show: tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:string</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].interpreter_interface memory at:1 put: (interpreter_interface opcode at:tempstr).</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].interpreter_interface memory at:1 put: (interpreter_interface opcode at:tempstr).^interpreter_interface memory.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp|tempstr := ''.len := 1.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifTrue:[tempstr := (tempstr,((program at:len) printString))]								ifFalse:[self AllocateMemorySingleLine: tempstr].	len:=len+1.	].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len|tempstr := ''.len := 1.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifTrue:[tempstr := (tempstr,((program at:len) printString))]								ifFalse:[self AllocateMemorySingleLine: tempstr].	len:=len+1.	].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len|tempstr := ''.len := 1.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifTrue:[tempstr := (tempstr,((program at:len) printString))]								ifFalse:[Transcript show: ((self AllocateMemorySingleLine: tempstr) printString)].	len:=len+1.	].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgramself AllocateMemory.</body></methods><do-it>Interpreter organization addCategory: #accessing</do-it><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="accumulator">accumulator	^accumulator</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="accumulator:">accumulator: anObject	accumulator := anObject</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="additional_register">additional_register	^additional_register</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="additional_register:">additional_register: anObject	additional_register := anObject</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="memory">memory	^memory</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="memory:">memory: anObject	memory := anObject</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="opcode_array">opcode_array	^opcode_array</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="opcode_array:">opcode_array: anObject	opcode_array := anObject</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="over_flow">over_flow	^over_flow</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="over_flow:">over_flow: anObject	over_flow := anObject</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="program_counter">program_counter	^program_counter</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="program_counter:">program_counter: anObject	program_counter := anObject</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="symbol_dict">symbol_dict	^symbol_dict</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="symbol_dict:">symbol_dict: anObject	symbol_dict := anObject</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="zero_result">zero_result	^zero_result</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="zero_result:">zero_result: anObject	zero_result := anObject</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].interpreter_interface memory at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory.</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	interpreter_interface := Interpreter_Interface new.	interpreter := Interpreter new.	interpreter_interface := interpreter.	(self widgetAt: #Label7)labelString: (interpreter_interface accumulator printString).	(self widgetAt: #Label8)labelString: (interpreter_interface additional_register printString).	(self widgetAt: #Label9)labelString: (interpreter_interface program_counter printString).	(self widgetAt: #Label10)labelString: (interpreter_interface zero_result printString).	(self widgetAt: #Label11)labelString: (interpreter_interface over_flow printString).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	(self widgetAt: #Label7)labelString: (interpreter_interface accumulator printString).	(self widgetAt: #Label8)labelString: (interpreter_interface additional_register printString).	(self widgetAt: #Label9)labelString: (interpreter_interface program_counter printString).	(self widgetAt: #Label10)labelString: (interpreter_interface zero_result printString).	(self widgetAt: #Label11)labelString: (interpreter_interface over_flow printString).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	(self widgetAt: #Label7)labelString:((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: (interpreter_interface additional_register printString).	(self widgetAt: #Label9)labelString: (interpreter_interface program_counter printString).	(self widgetAt: #Label10)labelString: (interpreter_interface zero_result printString).	(self widgetAt: #Label11)labelString: (interpreter_interface over_flow printString).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><do-it>params1 := OrderedCollection new.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.interpreter_inter accumulator.</do-it><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	(self widgetAt: #Label7)labelString:((interpreter accumulator) printString).	(self widgetAt: #Label8)labelString: (interpreter_interface additional_register printString).	(self widgetAt: #Label9)labelString: (interpreter_interface program_counter printString).	(self widgetAt: #Label10)labelString: (interpreter_interface zero_result printString).	(self widgetAt: #Label11)labelString: (interpreter_interface over_flow printString).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	(self widgetAt: #Label7)labelString:'((interpreter accumulator) printString)'.	(self widgetAt: #Label8)labelString: (interpreter_interface additional_register printString).	(self widgetAt: #Label9)labelString: (interpreter_interface program_counter printString).	(self widgetAt: #Label10)labelString: (interpreter_interface zero_result printString).	(self widgetAt: #Label11)labelString: (interpreter_interface over_flow printString).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].Transcript show: tempstr printString."(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr)."^interpreter_interface memory.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].(Transcript show: tempstr) printString."(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr)."^interpreter_interface memory.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].Transcript show: (tempstr printString)."(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr)."^interpreter_interface memory.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].Transcript show: (tempstr printString)."(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].Transcript show:tempstr."(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].Transcript show:((interpreter_interface opcode_array at:tempstr) printString)."(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><do-it>params1 := OrderedCollection new.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.interpreter_inter accumulator.(interpreter_inter opcode_array) at:'add'.</do-it><do-it>| str |str := ''.params1 := OrderedCollection new.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.interpreter_inter accumulator.str := str,'a'.str := str,'d'.str := str,'d'.(interpreter_inter opcode_array) at:str.</do-it><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].Transcript show:((interpreter_interface opcode_array at:tempstr) printString)."(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len|tempstr := ''.len := 1.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~~ (Character cr))ifTrue:[tempstr := (tempstr,((program at:len) printString))]								ifFalse:[Transcript show: ((self AllocateMemorySingleLine: tempstr) printString)].	len:=len+1.	].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len tempstr|len := 1.tempstr := ''.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifTrue:[tempstr := (tempstr,((line at:len) printString))]								ifFalse:[len:=(line size)].	len:=len+1.	].Transcript show:(((interpreter_interface opcode_array) at:tempstr) printString)."(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><do-it>str := 'abc'.chr := 'd'.str class.chr class.</do-it><do-it>str := 'abc'.chr := $d.str class.chr class.</do-it><do-it>str := 'abc'.chr := $d.str class.chr class.chr printString.</do-it><do-it>str := 'abc'.chr := $d.str class.chr class.str := str,(chr printString).</do-it><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: temp.Transcript show:(((interpreter_interface opcode_array) at:tempstr) printString)."(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~~ (Character cr))ifFalse:[tempstr:= program copyFrom: temp to: len. self AllocateMemorySingleLine: tempstr. temp := len+1].	len:=len+1.	].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~~ (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		Transcript show: tempstr].	len:=len+1.	].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: temp."Transcript show:(((interpreter_interface opcode_array) at:tempstr) printString).(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~~ (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	len:=len+1.	].^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: temp.Transcript show: tempstr."Transcript show:(((interpreter_interface opcode_array) at:tempstr) printString).(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr."Transcript show:(((interpreter_interface opcode_array) at:tempstr) printString).(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1)."Transcript show: tempstr."Transcript show:(((interpreter_interface opcode_array) at:tempstr) printString).(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory.</body></methods><do-it>params1 := OrderedCollection new.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.interpreter_inter accumulator.interpreter_inter opcode_array.</do-it><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1)."Transcript show: tempstr."Transcript show:(((interpreter_interface opcode_array) at:'lda') printString)."Transcript show:(((interpreter_interface opcode_array) at:tempstr) printString).(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: (tempstr class)."Transcript show:(((interpreter_interface opcode_array) at:tempstr) printString).(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: ((tempstr class) printString)."Transcript show:(((interpreter_interface opcode_array) at:tempstr) printString).(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><do-it>|  |str := str,'a'.str := str,'d'.str := str,'d'.temp := str copyFrom: 1 to: 2.temp class.</do-it><do-it>str := str,'a'.str := str,'d'.str := str,'d'.temp := str copyFrom: 1 to: 2.temp class.</do-it><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: (tempstr printString)."Transcript show:(((interpreter_interface opcode_array) at:tempstr) printString).(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory."</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show:(((interpreter_interface opcode_array) at:(tempstr printString)) printString).(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr).^interpreter_interface memory.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show:(((interpreter_interface opcode_array) at:(tempstr printString)) printString)."(interpreter_interface memory) at:1 put: (interpreter_interface opcode_array at:tempstr)."^interpreter_interface memory.</body></methods><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	symbol_dict := Dictionary new.	accumulator:=0.	additional_register:=0.	program_counter:=0.	zero_result:=0.	over_flow:=0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>opcode_array</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>opcode_array</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory accumulator additional_register program_counter zero_result over_flow symbol_dict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><remove-selector><class-id>Interpreter</class-id> <selector>opcode_array</selector></remove-selector><remove-selector><class-id>Interpreter</class-id> <selector>opcode_array:</selector></remove-selector><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr|len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).</body></methods><class><name>Interpreter</name><environment>Smalltalk</environment><super>Interpreter_Interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory accumulator additional_register program_counter zero_result over_flow symbol_dict currmemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	symbol_dict := Dictionary new.	currmemory := 0.	accumulator:=0.	additional_register:=0.	program_counter:=0.	zero_result:=0.	over_flow:=0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="currmemory">currmemory	^currmemory</body></methods><methods><class-id>Interpreter</class-id> <category>accessing</category><body package="CS474" selector="currmemory:">currmemory: anObject	currmemory := anObject</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr == 'add')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 1.].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr == 'add')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr == 'DEC')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDA')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDB')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~~ (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	len:=len+1.	].tempstr:=''.1 to: 256 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDA')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDB')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr.(tempstr = 'DEC')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDA')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDB')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := Program_Text value.[len &lt;= program size]whileTrue: [	((program at:len) ~~ (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	len:=len+1.	].tempstr:=''.1 to: 10 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr.(tempstr == 'DEC')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDA')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDB')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr.(tempstr = 'DEC')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDA')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDB')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr.(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDA')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDB')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr.(tempstr == 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDA')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDB')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr == 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr == 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr == 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><do-it>str1 := 'abcd'.str2 := str1 copyFrom: 1 to:3.str2 = 'abc'.</do-it><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: ((tempstr class) printString).Transcript show: (('LDA' class) printString).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).tempstr := (tempstr printString).Transcript show: ((tempstr class) printString).Transcript show: (('LDA' class) printString).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).tempstr := (tempstr printString).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).tempstr := (tempstr printString).(tempstr == 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).tempstr := (tempstr printString).Transcript show: tempstr.(tempstr == 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr == 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr |len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr.(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: (interpreter_interface currmemory) put: 1.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 2.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: (interpreter_interface currmemory) put: 3.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 4.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 5.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 6.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 7.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 8.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 9.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 10.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: (interpreter_interface currmemory) put: 11.	interpreter_interface currmemory:(interpreter_interface currmemory + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~~ (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	len:=len+1.	].tempstr:=''.1 to: 10 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr.(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~~ (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	len:=len+1.	].tempstr:=''.1 to: 10 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><do-it>interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.interpreter_inter accumulator.interpreter_inter memory.</do-it><do-it>params1 := OrderedCollection new.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.interpreter_inter accumulator.interpreter_inter memory at:10.</do-it><do-it>params1 := OrderedCollection new.interpreter_inter := Interpreter_Interface new.interpreter := Interpreter new.interpreter_inter := interpreter.interpreter_inter accumulator.(interpreter_inter memory) at:10. </do-it><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	symbol_dict := Dictionary new.	currmemory := 1.	accumulator:=0.	additional_register:=0.	program_counter:=0.	zero_result:=0.	over_flow:=0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 20, 2018' '4:06:38 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 4:06:38 AM on March 20, 2018."</do-it><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	interpreter_interface symbol_dict: tempstr].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	len:=len+1.	].tempstr:=''.1 to: 10 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].tempstr := (tempstr,((interpreter_interface symbol_dict) at: 'ABC') printString).Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	len:=len+1.	].tempstr:=''.1 to: 10 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: temp to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: temp to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'XCH')ifTrue: [interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JMP')ifTrue: [interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).].(tempstr = 'JVS')ifTrue: [interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'ADD')ifTrue: [interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).].(tempstr = 'HLT')ifTrue: [interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	(((program at:len) ~= (Character cr)) | (len == (program size)))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	(((program at:len) ~= (Character cr)) | (len ~= (program size)))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len+1). 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len+1). 		"self AllocateMemorySingleLine: tempstr. "		temp := len+1.		Transcript show: tempstr.		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: len. 		"self AllocateMemorySingleLine: tempstr. "		temp := len+1.		Transcript show: tempstr.		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: len. 		"self AllocateMemorySingleLine: tempstr. "		temp := len+1.		Transcript show: tempstr.		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)]."Transcript show:tempstr."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len-1). 		"self AllocateMemorySingleLine: tempstr. "		temp := len+1.		Transcript show: tempstr.		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)]."Transcript show:tempstr."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)]."Transcript show:tempstr."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	"temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1)."	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	"Transcript show: tempstr."	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	Transcript show: tempstr.	"temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1)."	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to: (len-1).	"Transcript show: tempstr."	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		"Transcript show: tempstr"].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)]."Transcript show:tempstr."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		Transcript show: tempstr].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		Transcript show: tempstr.		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)]."Transcript show:tempstr."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		"self AllocateMemorySingleLine: tempstr."		temp := len+1.		Transcript show: tempstr].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len). 		"self AllocateMemorySingleLine: tempstr."		temp := len+1.		Transcript show: tempstr.		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)]."Transcript show:tempstr."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		"self AllocateMemorySingleLine: tempstr."		temp := len+1.		Transcript show: tempstr,'--'].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len). 		"self AllocateMemorySingleLine: tempstr."		temp := len+1.		Transcript show: tempstr.		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)]."Transcript show:tempstr."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		Transcript show: tempstr,'--'].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len).		tempstr:=tempstr,(Character cr). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		Transcript show: tempstr.		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)]."Transcript show:tempstr."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		Transcript show: tempstr,'--'].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to: (len).		tempstr:=tempstr,((Character cr) printString). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		Transcript show: tempstr.		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)]."Transcript show:tempstr."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		Transcript show: tempstr,'--'].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to:len.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		Transcript show: tempstr.		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)]."Transcript show:tempstr."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to:len.	"Transcript show: tempstr."	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to:len.	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to:len.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)]."Transcript show:tempstr."^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to:(len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: len.	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to:(len-1).	Transcript show: tempstr.	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to:(len-1).	"Transcript show: tempstr."	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to:len.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		Transcript show: tempstr,'--'		].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to:len.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to:len.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp done|done := 0.tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to:len.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		done := 1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to:len.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	(len == (program size))ifTrue: [		tempstr:= program copyFrom: temp to:len.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	(((program at:len) ~= (Character cr)) &amp; (len ~= (program size)))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	(((program at:len) ~= (Character cr)) &amp; (len == (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	(((program at:len) ~= (Character cr)) &amp; (len == (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		Transcript show: tempstr.		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		Transcript show: tempstr,'--'		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	(((program at:len) ~= (Character cr)) &amp; (len == (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		"self AllocateMemorySingleLine: tempstr."		temp := len+1.		Transcript show: tempstr.		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		"self AllocateMemorySingleLine: tempstr."		temp := len+1.		Transcript show: tempstr,'--'		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	(((program at:len) ~= (Character cr)) &amp; (len == (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><do-it>|TEST|TEST := 'ABC'.TEST size.</do-it><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	(((program at:len) ~= (Character cr)) &amp; (len == (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		tempstr:=tempstr,' '.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	(((program at:len) ~= (Character cr)) &amp; (len = (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		tempstr:=tempstr,' '.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((len = (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		tempstr:=tempstr,' '.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((len == (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		tempstr:=tempstr,' '.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((len == (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		tempstr:=tempstr,' '.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		Transcript show: tempstr.		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((len == (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		tempstr:=tempstr,' '.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 20 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var |self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [					].	]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="lda:">lda:number| address |address := symbol_dict at:number.accumulator:=memory at: address.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldb:">ldb:number| address |address := symbol_dict at:number.additional_register:=memory at: address.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommad ldbcommand tempcoll|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommad ldbcommand tempcoll|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).		].	]</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ldacommand</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ldacommand</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommad ldbcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldacommand := Lda new:interpreter_interface.			onRun := TheCommand new:ldacommand.			onRun press.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldacommand := Lda new:interpreter_interface.			onRun := TheCommand new:ldacommand.			onRun press.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="lda:">lda:numberaccumulator:=memory at: number.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldb:">ldb:numberadditional_register:=memory at: number.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	]</body></methods><methods><class-id>Lda</class-id> <category>Methods</category><body package="CS474" selector="execute">executeTranscript show: ((Number class) printString).^Interpreter_int lda:Number.</body></methods><methods><class-id>Lda</class-id> <category>Methods</category><body package="CS474" selector="execute">executeTranscript show: ((Number class) printString).^Interpreter_int lda:number.</body></methods><methods><class-id>Lda</class-id> <category>Methods</category><body package="CS474" selector="execute">executeTranscript show: ((number class) printString).^Interpreter_int lda:number.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [				].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand  tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		]	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [		]	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		]	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		]	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [					].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:tempcoll.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:tempcoll.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:tempcoll.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:tempcoll.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:tempcoll.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].		]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:tempcoll.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:tempcoll.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	(self widgetAt: #Label7)labelString: (interpreter_interface accumulator)	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=4]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:tempcoll.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:tempcoll.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	(self widgetAt: #Label7)labelString: (interpreter_interface accumulator).	(self widgetAt: #Label8)labelString: (interpreter_interface additional_register).	(self widgetAt: #Label9)labelString: (interpreter_interface program_counter).	(self widgetAt: #Label10)labelString: (interpreter_interface zero_result).	(self widgetAt: #Label11)labelString: (interpreter_interface over_flow).	]</body></methods><class><name>Xch</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interpreter_inter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Xch</class-id> <category>accessing</category><body package="CS474" selector="interpreter_inter">interpreter_inter	^interpreter_inter</body></methods><methods><class-id>Xch</class-id> <category>accessing</category><body package="CS474" selector="interpreter_inter:">interpreter_inter: anObject	interpreter_inter := anObject</body></methods><methods><class-id>Xch</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	interpreter_inter := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Xch</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><do-it>Xch class organization addCategory: #'initialize-release'</do-it><methods><class-id>Xch class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:interpreter_int_new</body></methods><do-it>Xch class organization removeCategory: #'initialize-release'</do-it><methods><class-id>Xch class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:interpreter_int_new^super new interpreter_inter: interpreter_int_new.</body></methods><methods><class-id>Xch</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	interpreter_inter xch.</body></methods><methods><class-id>Xch</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	^interpreter_inter xch.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = -1)ifTrue: [		loc:=loc +1.].	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:tempcoll.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:tempcoll.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	(self widgetAt: #Label7)labelString: (interpreter_interface accumulator).	(self widgetAt: #Label8)labelString: (interpreter_interface additional_register).	(self widgetAt: #Label9)labelString: (interpreter_interface program_counter).	(self widgetAt: #Label10)labelString: (interpreter_interface zero_result).	(self widgetAt: #Label11)labelString: (interpreter_interface over_flow).	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = -1)ifTrue: [		loc:=loc +1.].	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := St new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:tempcoll.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:tempcoll.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register)printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter)printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result)printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow)printString).	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = -1)ifTrue: [		loc:=loc +1.].	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := Xch new:tempcoll.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:tempcoll.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:tempcoll.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register)printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter)printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result)printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow)printString).	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = -1)ifTrue: [		loc:=loc +1.].	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register)printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter)printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result)printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow)printString).	]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="xch">xch| temp |temp:=accumulator.accumulator:=additional_register.additional_register:=temp.Transcript show: 'im in xch'.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr.(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to:(len-1).	"Transcript show: tempstr."	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].temp:= temp+1.tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr.(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to:(len-1).	"Transcript show: tempstr."	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size.].temp:= temp+1.tempstr := line copyFrom: 1 to: (temp-1)."Transcript show: tempstr."(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to:(len-1).	"Transcript show: tempstr."	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="xch">xch| temp |temp:=accumulator.accumulator:=additional_register.additional_register:=temp.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp == 0)ifTrue: [temp:=line size. temp:= temp+1.].tempstr := line copyFrom: 1 to: (temp-1)."Transcript show: tempstr."(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	tempstr := line copyFrom: (temp+1) to:(len-1).	"Transcript show: tempstr."	(interpreter_interface symbol_dict) at: tempstr put: (curr).].(tempstr = 'LDA')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	"Transcript show: tempstr."	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict) at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue: [	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:= interpreter_interface currmemory.	tempstr := line copyFrom: (temp+1) to: (len-1).	(interpreter_interface memory) at: curr put: (tempstr asNumber).	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = -1)ifTrue: [		loc:=loc +1.].	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	interpreter_interface program_counter: loc.	(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register)printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter)printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result)printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow)printString).	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.loc := (interpreter_interface program_counter).[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = -1)ifTrue: [		loc:=loc +1.].	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	interpreter_interface program_counter: loc.	(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register)printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter)printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result)printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow)printString).	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.loc := (interpreter_interface program_counter).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand tempcoll onRun|self AllocateMemory.loc := 1.loc := (interpreter_interface program_counter).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.loc := (interpreter_interface program_counter).[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = -1)ifTrue: [		loc:=loc +1.].	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	interpreter_interface program_counter: loc.	(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register)printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter)printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result)printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow)printString).	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := 1.loc := (interpreter_interface program_counter).code := ((interpreter_interface memory) at:loc).(code = -1)ifTrue: [	loc:=loc +1.].(code = 1)ifTrue: [		loc := loc +2.	].(code = 2)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		Transcript show: ((var class) printString).		ldacommand := Lda new:tempcoll.		onRun := TheCommand new:ldacommand.		onRun press.		loc := loc +1.		Transcript show: ((interpreter_interface accumulator)printString).	].(code = 3)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		ldbcommand := Ldb new:tempcoll.		onRun := TheCommand new:ldbcommand.		onRun press.		loc := loc +1.	].(code = 4)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		ldicommand := Ldi new:tempcoll.		onRun := TheCommand new:ldicommand.		onRun press.		loc := loc +1.		].(code = 5)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		stcommand := St new:tempcoll.		onRun := TheCommand new:stcommand.		onRun press.		loc := loc +1.	].(code = 6)ifTrue: [		xchcommand := Xch new:interpreter_interface.		onRun := TheCommand new:xchcommand.		onRun press.		loc := loc +1.	].(code = 7)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		jmpcommand := Jmp new:tempcoll.		onRun := TheCommand new:jmpcommand.		onRun press.		loc := (interpreter_interface program_counter).	].(code = 8)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		jzscommand := Jzs new:tempcoll.		onRun := TheCommand new:jzscommand.		onRun press.		loc := (interpreter_interface program_counter).	].(code = 9)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		jvscommand := Jvs new:tempcoll.		onRun := TheCommand new:jvscommand.		onRun press.		loc := (interpreter_interface program_counter).	].(code = 10)ifTrue: [		addcommand := Add new:interpreter_interface.		onRun := TheCommand new:addcommand.		onRun press.		loc := loc +1.	].(code = 11)ifTrue: [		hltcommand := Hlt new:interpreter_interface.		onRun := TheCommand new:hltcommand.		onRun press.		loc := 257.	].interpreter_interface program_counter: loc.(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register)printString).(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter)printString).(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result)printString).(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow)printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := (interpreter_interface program_counter).(loc = 0)ifTrue: [loc:=1.].code := ((interpreter_interface memory) at:loc).(code = -1)ifTrue: [	loc:=loc +1.].(code = 1)ifTrue: [		loc := loc +2.	].(code = 2)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		Transcript show: ((var class) printString).		ldacommand := Lda new:tempcoll.		onRun := TheCommand new:ldacommand.		onRun press.		loc := loc +1.		Transcript show: ((interpreter_interface accumulator)printString).	].(code = 3)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		ldbcommand := Ldb new:tempcoll.		onRun := TheCommand new:ldbcommand.		onRun press.		loc := loc +1.	].(code = 4)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		ldicommand := Ldi new:tempcoll.		onRun := TheCommand new:ldicommand.		onRun press.		loc := loc +1.		].(code = 5)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		stcommand := St new:tempcoll.		onRun := TheCommand new:stcommand.		onRun press.		loc := loc +1.	].(code = 6)ifTrue: [		xchcommand := Xch new:interpreter_interface.		onRun := TheCommand new:xchcommand.		onRun press.		loc := loc +1.	].(code = 7)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		jmpcommand := Jmp new:tempcoll.		onRun := TheCommand new:jmpcommand.		onRun press.		loc := (interpreter_interface program_counter).	].(code = 8)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		jzscommand := Jzs new:tempcoll.		onRun := TheCommand new:jzscommand.		onRun press.		loc := (interpreter_interface program_counter).	].(code = 9)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		jvscommand := Jvs new:tempcoll.		onRun := TheCommand new:jvscommand.		onRun press.		loc := (interpreter_interface program_counter).	].(code = 10)ifTrue: [		addcommand := Add new:interpreter_interface.		onRun := TheCommand new:addcommand.		onRun press.		loc := loc +1.	].(code = 11)ifTrue: [		hltcommand := Hlt new:interpreter_interface.		onRun := TheCommand new:hltcommand.		onRun press.		loc := 257.	].interpreter_interface program_counter: loc.(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register)printString).(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter)printString).(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result)printString).(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow)printString).</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="add">add| temp |temp:=accumulator+additional_register.accumulator:=temp.(temp = 0)ifTrue: [		zero_result := 1.	].^accumulator.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="add">add| temp |temp:=accumulator+additional_register.accumulator:=temp.(temp = 0)ifTrue: [		zero_result := 1.	]ifFalse: [		zero_result:= 0.	].^accumulator.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jzs:">jzs:number[zero_result=1]ifTrue:[program_counter:=number.]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:number[over_flow=1]ifTrue:[program_counter:=number.]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := (interpreter_interface program_counter).(loc =0)ifTrue: [loc:=1.].[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = -1)ifTrue: [		loc:=loc +1.].	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	interpreter_interface program_counter: loc.	(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register)printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter)printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result)printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow)printString).	]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jzs:">jzs:number[zero_result==1]ifTrue:[program_counter:=number.]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:number[over_flow==1]ifTrue:[program_counter:=number.]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jzs:">jzs:number(zero_result=1)ifTrue:[program_counter:=number.]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:number(over_flow=1)ifTrue:[program_counter:=number.]</body></methods><do-it>10 class.</do-it><do-it>10 class.</do-it><do-it>10 class.</do-it><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="lda:">lda:number(number class =  SmallInteger)ifTrue: [accumulator:=memory at: number.]ifFalse: [		accumulator:=memory at:(symbol_dict at:number).	].</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldb:">ldb:number(number class =  SmallInteger)ifTrue: [additional_register :=memory at: number.]ifFalse: [		additional_register :=memory at:(symbol_dict at:number).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((len == (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		tempstr:=tempstr,' '.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 50 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|(((interpreter_interface memory) at:1)= -1)ifTrue: [self AllocateMemory.].loc := (interpreter_interface program_counter).(loc = 0)ifTrue: [loc:=1.].code := ((interpreter_interface memory) at:loc).(code = -1)ifTrue: [	loc:=loc +1.].(code = 1)ifTrue: [		loc := loc +2.	].(code = 2)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		Transcript show: ((var class) printString).		ldacommand := Lda new:tempcoll.		onRun := TheCommand new:ldacommand.		onRun press.		loc := loc +1.		Transcript show: ((interpreter_interface accumulator)printString).	].(code = 3)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		ldbcommand := Ldb new:tempcoll.		onRun := TheCommand new:ldbcommand.		onRun press.		loc := loc +1.	].(code = 4)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		ldicommand := Ldi new:tempcoll.		onRun := TheCommand new:ldicommand.		onRun press.		loc := loc +1.		].(code = 5)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		stcommand := St new:tempcoll.		onRun := TheCommand new:stcommand.		onRun press.		loc := loc +1.	].(code = 6)ifTrue: [		xchcommand := Xch new:interpreter_interface.		onRun := TheCommand new:xchcommand.		onRun press.		loc := loc +1.	].(code = 7)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		jmpcommand := Jmp new:tempcoll.		onRun := TheCommand new:jmpcommand.		onRun press.		loc := (interpreter_interface program_counter).	].(code = 8)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		jzscommand := Jzs new:tempcoll.		onRun := TheCommand new:jzscommand.		onRun press.		loc := (interpreter_interface program_counter).	].(code = 9)ifTrue: [		tempcoll := OrderedCollection new.		tempcoll add:interpreter_interface.		loc := loc +1.		var := ((interpreter_interface memory) at:loc).		tempcoll add: var.		jvscommand := Jvs new:tempcoll.		onRun := TheCommand new:jvscommand.		onRun press.		loc := (interpreter_interface program_counter).	].(code = 10)ifTrue: [		addcommand := Add new:interpreter_interface.		onRun := TheCommand new:addcommand.		onRun press.		loc := loc +1.	].(code = 11)ifTrue: [		hltcommand := Hlt new:interpreter_interface.		onRun := TheCommand new:hltcommand.		onRun press.		loc := 257.	].interpreter_interface program_counter: loc.(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register)printString).(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter)printString).(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result)printString).(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow)printString).</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jzs:">jzs:number(zero_result=1)ifTrue:[program_counter:=number.]ifFalse: [program_counter:=program_counter+2.].</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:number(over_flow=1)ifTrue:[program_counter:=number.]ifFalse: [program_counter:=program_counter+2.].</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code var ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jzscommand jvscommand  addcommand hltcommand tempcoll onRun|self AllocateMemory.loc := (interpreter_interface program_counter).(loc ~=1)ifTrue: [loc:=1.].[loc &lt;=256]whileTrue: [	code := ((interpreter_interface memory) at:loc).	(code = -1)ifTrue: [		loc:=loc +1.].	(code = 1)ifTrue: [			loc := loc +2.		].	(code = 2)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			Transcript show: ((var class) printString).			ldacommand := Lda new:tempcoll.			onRun := TheCommand new:ldacommand.			onRun press.			loc := loc +1.			Transcript show: ((interpreter_interface accumulator)printString).		].	(code = 3)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldbcommand := Ldb new:tempcoll.			onRun := TheCommand new:ldbcommand.			onRun press.			loc := loc +1.		].	(code = 4)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			ldicommand := Ldi new:tempcoll.			onRun := TheCommand new:ldicommand.			onRun press.			loc := loc +1.			].	(code = 5)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			stcommand := St new:tempcoll.			onRun := TheCommand new:stcommand.			onRun press.			loc := loc +1.		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			loc := loc +1.		].	(code = 7)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jmpcommand := Jmp new:tempcoll.			onRun := TheCommand new:jmpcommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 8)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jzscommand := Jzs new:tempcoll.			onRun := TheCommand new:jzscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 9)ifTrue: [			tempcoll := OrderedCollection new.			tempcoll add:interpreter_interface.			loc := loc +1.			var := ((interpreter_interface memory) at:loc).			tempcoll add: var.			jvscommand := Jvs new:tempcoll.			onRun := TheCommand new:jvscommand.			onRun press.			loc := (interpreter_interface program_counter).		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			loc := loc +1.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.			loc := 257.		].	interpreter_interface program_counter: loc.	(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register)printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter)printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result)printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow)printString).	]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="lda:">lda:number(number class ==  SmallInteger)ifTrue: [accumulator:=memory at: number.]ifFalse: [		accumulator:=memory at:(symbol_dict at:number).	].</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldb:">ldb:number(number class ==  SmallInteger)ifTrue: [additional_register :=memory at: number.]ifFalse: [		additional_register :=memory at:(symbol_dict at:number).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((len == (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		tempstr:=tempstr,' '.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 150 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program:=''.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((len == (program size)))ifTrue: [		tempstr:= program copyFrom: temp to:len.		tempstr:=tempstr,' '.		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr."		].	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: (len-1). 		self AllocateMemorySingleLine: tempstr.		temp := len+1.		"Transcript show: tempstr,'--'"		].	len:=len+1.	].tempstr:=''.1 to: 150 do:[:x|tempstr := (tempstr,'--',((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		Transcript show: tempstr].	len:=len+1.	].tempstr:=''.1 to: 10 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=len].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		Transcript show: tempstr].	len:=len+1.	].tempstr:=''.1 to: 30 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 21, 2018' '11:29:12 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 11:29:12 AM on March 21, 2018."</do-it><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompletePrograminterpreter_interface.self AllocateMemory.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompletePrograminterpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 21, 2018' '11:31:30 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 11:31:30 AM on March 21, 2018."</do-it><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	Transcript show: (curr printString).	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		].	len:=len+1.	].tempstr:=''.1 to: 30 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		Transcript show: tempstr.		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		].	len:=len+1.	].tempstr:=''.1 to: 30 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr.(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		].	len:=len+1.	].tempstr:=''.1 to: 30 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).Transcript show: tempstr,'----'.(tempstr = 'DEC')ifTrue: [	Transcript show: tempstr.	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.		].	(code = 2)ifTrue: [					]		]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand onRun|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.		].	(code = 2)ifTrue: [			ldacommand := Lda new:interpreter_interface.			onRun := TheCommand new:ldacommand.			onRun press.		]		]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add: interpreter_interface.			ldacommand := Lda new:interpreter_interface.			onRun := TheCommand new:ldacommand.			onRun press.		]		]</body></methods><methods><class-id>Lda</class-id> <category>Methods</category><body package="CS474" selector="execute">execute^Interpreter_int lda:number.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		]		]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.		].	]</body></methods><class><name>Xch</name><environment>Smalltalk</environment><super>Command_interface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interpreter_int </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>Xch</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int">interpreter_int	^interpreter_int</body></methods><methods><class-id>Xch</class-id> <category>accessing</category><body package="CS474" selector="interpreter_int:">interpreter_int: anObject	interpreter_int := anObject</body></methods><methods><class-id>Xch</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	interpreter_int := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Xch</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	" *** This method was defined by Command_interface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><do-it>Xch class organization addCategory: #'initialize-release'</do-it><methods><class-id>Xch class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new:interpreter_int_new^super new interpreter_int: interpreter_int_new.</body></methods><do-it>Xch class organization removeCategory: #'initialize-release'</do-it><methods><class-id>Xch</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	interpreter_int xch.</body></methods><methods><class-id>Xch</class-id> <category>Methods</category><body package="CS474" selector="execute">execute	^interpreter_int xch.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.		].	(code = 6)ifTrue: [			xchcommand := Ldi new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.		].	(code = 6)ifTrue: [			xchcommand := Ldi new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Ldi new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:coll.			onRun := TheCommand new:addcommand.			onRun press.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:coll.			onRun := TheCommand new:hltcommand.			onRun press.		].	]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 21, 2018' '12:01:46 PM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 12:01:46 PM on March 21, 2018."</do-it><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="add">add| temp |temp:=accumulator+additional_register.accumulator:=temp.(temp = 0)ifTrue: [zero_result:=1]ifFalse: [zero_result=0].(temp class ~~ SmallInteger)ifTrue: [over_flow:=1] ifFalse: [over_flow:=0].^accumulator.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="add">add| temp |temp:=accumulator+additional_register.accumulator:=temp.(temp = 0)ifTrue: [zero_result:=1]ifFalse: [zero_result:=0].(temp class ~~ SmallInteger)ifTrue: [over_flow:=1] ifFalse: [over_flow:=0].^accumulator.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="dec:at:">dec:symbol at:position</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="hlt">hltprogram_counter:=257.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:number[over_flow=1]ifTrue:[program_counter:=number.]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:number(over_flow=1)ifTrue:[program_counter:=number.]ifFalse: [program_counter:=program_counter+2]</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jzs:">jzs:number(zero_result=1)ifTrue:[program_counter:=number.]ifFalse: [program_counter:=program_counter+2]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:coll.			onRun := TheCommand new:addcommand.			onRun press.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:coll.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.		]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:coll.			onRun := TheCommand new:addcommand.			onRun press.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:coll.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).	]</body></methods><methods><class-id>Interpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	memory:=Array new:256.	1 to:256 do: [:x|memory at:x put: -1].	symbol_dict := Dictionary new.	currmemory := 1.	accumulator:=0.	additional_register:=0.	program_counter:=1.	zero_result:=0.	over_flow:=0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:coll.			onRun := TheCommand new:addcommand.			onRun press.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:coll.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr|curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:coll.			onRun := TheCommand new:addcommand.			onRun press.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:coll.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:coll.			onRun := TheCommand new:addcommand.			onRun press.		].	(code = 11)ifTrue: [			hltcommand := Hlt new:coll.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:coll.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:coll.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			loc:=loc+2.			interpreter_interface program_counter: loc.		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:coll.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:coll.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 21, 2018' '12:44:58 PM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 12:44:58 PM on March 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 21, 2018' '12:45:02 PM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 12:45:02 PM on March 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 21, 2018' '12:45:05 PM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 12:45:05 PM on March 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 21, 2018' '12:45:09 PM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 12:45:09 PM on March 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 21, 2018' '12:45:15 PM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 12:45:15 PM on March 21, 2018."</do-it><do-it>2 raisedTo:29.</do-it><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="add">add| temp |temp:=accumulator+additional_register.accumulator:=temp.(temp = 0)ifTrue: [zero_result:=1]ifFalse: [zero_result:=0].((temp &gt;((2 raisedTo:29)+1)))ifTrue: [over_flow:=1.accumulator:=(temp-((2raisedTo:29)+1)).].((temp &lt;(0-(2 raisedTo:29)-1)))ifTrue: [over_flow:=1.accumulator:=(temp+(0-(2 raisedTo:29)-1)).].((temp &gt;((2 raisedTo:29)+1)) | (temp &lt;(0-(2 raisedTo:29)-1)))ifFalse: [over_flow:=0.].^accumulator.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="add">add| temp |temp:=accumulator+additional_register.accumulator:=temp.(temp = 0)ifTrue: [zero_result:=1]ifFalse: [zero_result:=0].((temp &gt;((2 raisedTo:29)+1)))ifTrue: [over_flow:=1.accumulator:=(temp-((2raisedTo:29)+1)).].((temp &lt;(0-(2 raisedTo:29)-1)))ifTrue: [over_flow:=1.accumulator:=(temp-(0-(2 raisedTo:29)-1)).].((temp &gt;((2 raisedTo:29)+1)) | (temp &lt;(0-(2 raisedTo:29)-1)))ifFalse: [over_flow:=0.].^accumulator.</body></methods><do-it>536870910 class.</do-it><do-it>536870999 class.</do-it><do-it>(2 raisedTo:29)+1.</do-it><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|((interpreter_interface memory) at:1) = -1 ifTrue: [self AllocateMemory.].loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|((interpreter_interface memory) at:1) = -1 ifTrue: [self AllocateMemory.].loc := interpreter_interface program_counter.code:=((interpreter_interface memory) at:loc).(code =1)ifTrue: [		interpreter_interface program_counter:(loc+2).	].(code = 2)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldacommand := Lda new:coll.		onRun := TheCommand new:ldacommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].(code = 3)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldbcommand := Ldb new:coll.		onRun := TheCommand new:ldbcommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].	(code = 4)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldicommand := Ldi new:coll.		onRun := TheCommand new:ldicommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].	(code = 5)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		stcommand := St new:coll.		onRun := TheCommand new:stcommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].(code = 6)ifTrue: [		xchcommand := Xch new:interpreter_interface.		onRun := TheCommand new:xchcommand.		onRun press.		interpreter_interface program_counter:(loc+1).	].(code = 7)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jmpcommand := Jmp new:coll.		onRun := TheCommand new:jmpcommand.		onRun press.	].(code = 8)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jzscommand := Jzs new:coll.		onRun := TheCommand new:jzscommand.		onRun press.	].(code = 9)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jvscommand := Jvs new:coll.		onRun := TheCommand new:jvscommand.		onRun press.	].(code = 10)ifTrue: [		addcommand := Add new:interpreter_interface.		onRun := TheCommand new:addcommand.		onRun press.		interpreter_interface program_counter:(loc+1).	].(code = 11)ifTrue: [		hltcommand := Hlt new:interpreter_interface.		onRun := TheCommand new:hltcommand.		onRun press.	].loc:=interpreter_interface program_counter.(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 22, 2018' '4:01:05 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 4:01:05 AM on March 22, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 22, 2018' '4:01:12 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 4:01:12 AM on March 22, 2018."</do-it><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MainInterpreter' 			#bounds: #(#{Graphics.Rectangle} 259 100 1022 581 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 88 0 25 0 ) 					#name: #Label1 					#label: 'State''s of the registers' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 68 0 62 0 ) 					#name: #Label2 					#label: 'Accumulator :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 68 0 94 0 ) 					#name: #Label3 					#label: 'Additional Register :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 68 0 126 0 ) 					#name: #Label4 					#label: 'Program Counter :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 68 0 158 0 ) 					#name: #Label5 					#label: 'Zero Result :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 68 0 190 0 ) 					#name: #Label6 					#label: 'Overflow :' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 337 0 23 0 695 0 219 0 ) 					#name: #TextEditor1 					#model: #Program_Text 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 338 0 241 0 503 0 262 0 ) 					#name: #ActionButton1 					#model: #ExecuteCurrentLine 					#label: 'Execute Current Line' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 533 0 241 0 698 0 262 0 ) 					#name: #ActionButton2 					#model: #ExecuteCompleteProgram 					#label: 'Execute Complete Program' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 204 0 63 0 ) 					#name: #Label7 					#label: 'nil' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 204 0 95 0 ) 					#name: #Label8 					#label: 'nil' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 204 0 127 0 ) 					#name: #Label9 					#label: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 204 0 159 0 ) 					#name: #Label10 					#label: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 204 0 191 0 ) 					#name: #Label11 					#label: '0' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 76 0 324 0 742 0 445 0 ) 					#name: #TextEditor2 					#model: #Console 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 79 0 296 0 ) 					#name: #Label12 					#label: 'Console' ) ) ) )</body></methods><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Accumulator Program_Counter Zero_Result Additional_Register Overflow Program_Text interpreter_interface interpreter program Console </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #MainInterpreter	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'Accumulator Program_Counter Zero_Result Additional_Register Overflow Program_Text interpreter_interface interpreter program  Console '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Program_Text">Program_Text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Program_Text isNil		ifTrue:			[Program_Text := String new asValue]		ifFalse:			[Program_Text]</body></methods><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Console">Console	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Console isNil		ifTrue:			[Console := String new asValue]		ifFalse:			[Console]</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	Console value: ('hello world' asText).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	Console value:'abc'.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	Console value: ('abc' asValue).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	Console value: ('abc').	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	Console value:'abc'.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	Console setValue: 'abc'.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	Console setValue: ('abc'asValue).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	Console setText: ('abc'asValue).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	Console setText: ('abc'asText).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	Console := ('abc' asValue).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	Console := ('Please leave 1 line in the start and 1 line at the end of the program for proper execution' asValue).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll console_text|console_text := (Console value printString).interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll console_text|console_text := ((Console value) printString).interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			console_text:=console_text, (onRun press).			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="hlt">hltprogram_counter:=257.^'You have reached the end of the program'.</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jmp:">jmp:number(number &gt;256)ifTrue: [^'number entered is out of memory'].(number &lt;1)ifTrue: [^'number entered is out of memory'].((number &lt;257) &amp; (number &gt;0))ifTrue: [program_counter:=number.].</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jvs:">jvs:number(number &gt;256)ifTrue: [^'number entered is out of memory'].(number &lt;1)ifTrue: [^'number entered is out of memory'].((number &lt;257) &amp; (number &gt;0))ifTrue: [(over_flow=1)ifTrue:[program_counter:=number.]ifFalse: [program_counter:=program_counter+2].].</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="jzs:">jzs:number(number &gt;256)ifTrue: [^'number entered is out of memory'].(number &lt;1)ifTrue: [^'number entered is out of memory'].((number &lt;257) &amp; (number &gt;0))ifTrue: [(zero_result=1)ifTrue:[program_counter:=number.]ifFalse: [program_counter:=program_counter+2].].</body></methods><do-it>| dic |dic := Dictionary new.dic at:'add' put:1.dic includesKey:'add'.</do-it><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=con_value,'an undeclared varibale is being used in program'].	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=con_value,'an undeclared varibale is being used in program']ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=con_value,'an undeclared varibale is being used in program']ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=con_value,'an undeclared varibale is being used in program']ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=((con_value,'an undeclared varibale is being used in program') asValue)]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=((con_value,'an undeclared varibale is being used in program') asValue)]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=((con_value,'an undeclared varibale is being used in program') asValue)]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=((con_value,'an undeclared varibale is being used in program') asValue).interpreter_interface currmemory:257]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=((con_value,'an undeclared varibale is being used in program') asValue).interpreter_interface currmemory:257.]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=((con_value,'an undeclared varibale is being used in program') asValue).interpreter_interface currmemory:257.]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].Console:=((con_value,'an undeclared varibale is being used in program') asValue).(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [interpreter_interface currmemory:257.]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=((con_value,'an undeclared varibale is being used in program') asValue).interpreter_interface currmemory:257.]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].Console:=((con_value,'an undeclared varibale is being used in program') asValue).(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [(interpreter_interface memory) at: curr put: -1.interpreter_interface currmemory:(curr + 1).]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [Console:=((con_value,'an undeclared varibale is being used in program') asValue).interpreter_interface currmemory:257.]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].Console:=((con_value,'an undeclared varibale is being used in program') asValue).(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [(interpreter_interface memory) at: curr put: -1.interpreter_interface currmemory:(curr + 1).]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [(interpreter_interface memory) at: curr put: -1.interpreter_interface currmemory:(curr + 1).]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].Console:=((con_value,'an undeclared varibale is being used in program') asValue).(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [(interpreter_interface memory) at: curr put: -1.interpreter_interface currmemory:(curr + 1).]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [(interpreter_interface memory) at: curr put: -1.interpreter_interface currmemory:(curr + 1).]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].Console:=((con_value,'an undeclared varibale is being used in program') asValue).(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [(interpreter_interface memory) at: curr put: -1.interpreter_interface currmemory:(curr + 1).]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [(interpreter_interface memory) at: curr put: -1.interpreter_interface currmemory:(curr + 1).]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr con_value|con_value:=Console value printString.curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [(interpreter_interface memory) at: curr put: -1.interpreter_interface currmemory:(curr + 1).]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [(interpreter_interface memory) at: curr put: -1.interpreter_interface currmemory:(curr + 1).]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemorySingleLine:">AllocateMemorySingleLine:line| len temp tempstr curr |curr := interpreter_interface currmemory.len := 1.temp := 0.[len &lt;= line size]whileTrue: [	((line at:len) ~= (Character space))ifFalse:[temp := len].	len:=len+1.	].(temp =0)ifTrue: [temp:=(len-1)].tempstr := line copyFrom: 1 to: (temp-1).(tempstr = 'DEC')ifTrue: [	(interpreter_interface memory) at: curr put: 1.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr put: curr).	(interpreter_interface memory) at: curr put: 0.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'LDA')ifTrue: [	(interpreter_interface memory) at: curr put: 2.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [(interpreter_interface memory) at: curr put: -1.interpreter_interface currmemory:(curr + 1).]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDB')ifTrue: [	(interpreter_interface memory) at: curr put: 3.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	((interpreter_interface symbol_dict)includesKey: tempstr)ifFalse: [(interpreter_interface memory) at: curr put: -1.interpreter_interface currmemory:(curr + 1).]ifTrue:[	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].	].(tempstr = 'LDI')ifTrue: [	interpreter_interface memory at: curr put: 4.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	Transcript show: tempstr,'---'.	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ST')ifTrue: [	interpreter_interface memory at: curr put: 5.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=((interpreter_interface symbol_dict)at: tempstr).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'XCH')ifTrue:[	interpreter_interface memory at: curr put: 6.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JMP')ifTrue: [	interpreter_interface memory at: curr put: 7.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JZS')ifTrue: [	interpreter_interface memory at: curr put: 8.	interpreter_interface currmemory:(curr+ 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'JVS')ifTrue: [	interpreter_interface memory at: curr put: 9.	interpreter_interface currmemory:(curr + 1).	curr:=interpreter_interface currmemory.	tempstr:=line copyFrom: (temp+1) to: (len-1).	temp:=(tempstr asNumber).	(interpreter_interface memory) at: curr put: temp.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'ADD')ifTrue: [	interpreter_interface memory at: curr put: 10.	interpreter_interface currmemory:(curr + 1).	].(tempstr = 'HLT')ifTrue: [	interpreter_interface memory at: curr put: 11.	interpreter_interface currmemory:(curr + 1).	].</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="lda:">lda:number(number = -1)ifTrue: [^'an undeclared varibale is being used in program'.]ifFalse:[accumulator:=memory at:number.].</body></methods><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="ldb:">ldb:number(number = -1)ifTrue: [^'an undeclared varibale is being used in program'.]ifFalse:[additional_register :=memory at:number.].</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll console_text|console_text := ((Console value) printString).interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			console_text:=console_text,((onRun press)printString).			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll console_text|console_text := ((Console value) printString).interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			console_text:=console_text,((onRun press)printString).			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).	Console := console_text asValue.</body></methods><do-it>hltcommand := Hlt new:interpreter_inter.onRun := TheCommand new:hltcommand.onRun press.</do-it><methods><class-id>Interpreter</class-id> <category>Methods</category><body package="CS474" selector="lda:">lda:number(number = -1)ifTrue: [^'an undeclared varibale is being used in program'.]ifFalse:[accumulator:=memory at:number.^''].</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll console_text|console_text := ((Console value) printString).interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			((((interpreter_interface memory) at:(loc+1)) asNumber) = -1)ifTrue: [console_text:=console_text,'an undeclared variable is used in this code'].			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).	Console := console_text asValue.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll console_text|console_text := ((Console value) printString).interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			((((interpreter_interface memory) at:(loc+1)) asNumber) = -1)ifTrue: [console_text:=console_text,'an undeclared variable is used in this code'.Console := console_text asValue.].			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).		</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll console_text|console_text := ((Console value) printString).interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			((((interpreter_interface memory) at:(loc+1))) = '-1')ifTrue: [console_text:=console_text,'an undeclared variable is used in this code'.Console := console_text asValue.].			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll console_text|console_text := ((Console value) printString).interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			((((interpreter_interface memory) at:(loc+1))) = -1)ifTrue: [console_text:=console_text,'an undeclared variable is used in this code'.Console := console_text asValue.].			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll console_text|console_text := ((Console value) printString).console_text:=console_text,'hahah'.Console:= console_text asValue.interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			((((interpreter_interface memory) at:(loc+1))) = -1)ifTrue: [console_text:=console_text,'an undeclared variable is used in this code'.Console := console_text asValue.].			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><do-it>str:='haha'.str:=str,'hehe'.str.</do-it><methods><class-id>MainInterpreter</class-id> <category>Methods</category><body package="CS474" selector="AllocateMemory">AllocateMemory|  tempstr len temp |tempstr := ''.len := 1.temp := 1.program := ((Program_Text value) printString).[len &lt;= program size]whileTrue: [	((program at:len) ~= (Character cr))ifFalse:[		tempstr:= program copyFrom: temp to: len. 		self AllocateMemorySingleLine: tempstr. 		temp := len+1.		].	len:=len+1.	].tempstr:=''.1 to: 256 do:[:x|tempstr := (tempstr,((interpreter_interface memory) at: x) printString)].Transcript show:tempstr.^self.</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|((interpreter_interface memory) at:1) = -1 ifTrue: [self AllocateMemory.].loc := interpreter_interface program_counter.(loc&gt;256)ifTrue: [Console:='reached end of the program'.]ifFalse:[code:=((interpreter_interface memory) at:loc).(code =1)ifTrue: [		interpreter_interface program_counter:(loc+2).	].(code = 2)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldacommand := Lda new:coll.		onRun := TheCommand new:ldacommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].(code = 3)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldbcommand := Ldb new:coll.		onRun := TheCommand new:ldbcommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].	(code = 4)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldicommand := Ldi new:coll.		onRun := TheCommand new:ldicommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].	(code = 5)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		stcommand := St new:coll.		onRun := TheCommand new:stcommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].(code = 6)ifTrue: [		xchcommand := Xch new:interpreter_interface.		onRun := TheCommand new:xchcommand.		onRun press.		interpreter_interface program_counter:(loc+1).	].(code = 7)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jmpcommand := Jmp new:coll.		onRun := TheCommand new:jmpcommand.		onRun press.	].(code = 8)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jzscommand := Jzs new:coll.		onRun := TheCommand new:jzscommand.		onRun press.	].(code = 9)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jvscommand := Jvs new:coll.		onRun := TheCommand new:jvscommand.		onRun press.	].(code = 10)ifTrue: [		addcommand := Add new:interpreter_interface.		onRun := TheCommand new:addcommand.		onRun press.		interpreter_interface program_counter:(loc+1).	].(code = 11)ifTrue: [		hltcommand := Hlt new:interpreter_interface.		onRun := TheCommand new:hltcommand.		onRun press.	].loc:=interpreter_interface program_counter.(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|((interpreter_interface memory) at:1) = -1 ifTrue: [self AllocateMemory.].loc := interpreter_interface program_counter.(loc&gt;256)ifTrue: [Console:='reached end of the program' asValue.]ifFalse:[code:=((interpreter_interface memory) at:loc).(code =1)ifTrue: [		interpreter_interface program_counter:(loc+2).	].(code = 2)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldacommand := Lda new:coll.		onRun := TheCommand new:ldacommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].(code = 3)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldbcommand := Ldb new:coll.		onRun := TheCommand new:ldbcommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].	(code = 4)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldicommand := Ldi new:coll.		onRun := TheCommand new:ldicommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].	(code = 5)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		stcommand := St new:coll.		onRun := TheCommand new:stcommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].(code = 6)ifTrue: [		xchcommand := Xch new:interpreter_interface.		onRun := TheCommand new:xchcommand.		onRun press.		interpreter_interface program_counter:(loc+1).	].(code = 7)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jmpcommand := Jmp new:coll.		onRun := TheCommand new:jmpcommand.		onRun press.	].(code = 8)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jzscommand := Jzs new:coll.		onRun := TheCommand new:jzscommand.		onRun press.	].(code = 9)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jvscommand := Jvs new:coll.		onRun := TheCommand new:jvscommand.		onRun press.	].(code = 10)ifTrue: [		addcommand := Add new:interpreter_interface.		onRun := TheCommand new:addcommand.		onRun press.		interpreter_interface program_counter:(loc+1).	].(code = 11)ifTrue: [		hltcommand := Hlt new:interpreter_interface.		onRun := TheCommand new:hltcommand.		onRun press.	].loc:=interpreter_interface program_counter.(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).].</body></methods><methods><class-id>MainInterpreter</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"interpreter_interface := Interpreter_Interface new."	interpreter := Interpreter new.	interpreter_interface := interpreter.	"Console := ('Please leave 1 line in the start and 1 line at the end of the program for proper execution' asValue)."	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCurrentLine">ExecuteCurrentLine| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll|((interpreter_interface memory) at:1) = -1 ifTrue: [self AllocateMemory.].loc := interpreter_interface program_counter.(loc&gt;256)ifTrue: [(self widgetAt: #Label13)labelString: 'You have reached the end of your program'.]ifFalse:[code:=((interpreter_interface memory) at:loc).(code =1)ifTrue: [		interpreter_interface program_counter:(loc+2).	].(code = 2)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldacommand := Lda new:coll.		onRun := TheCommand new:ldacommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].(code = 3)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldbcommand := Ldb new:coll.		onRun := TheCommand new:ldbcommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].	(code = 4)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		ldicommand := Ldi new:coll.		onRun := TheCommand new:ldicommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].	(code = 5)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		stcommand := St new:coll.		onRun := TheCommand new:stcommand.		onRun press.		interpreter_interface program_counter:(loc+2).	].(code = 6)ifTrue: [		xchcommand := Xch new:interpreter_interface.		onRun := TheCommand new:xchcommand.		onRun press.		interpreter_interface program_counter:(loc+1).	].(code = 7)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jmpcommand := Jmp new:coll.		onRun := TheCommand new:jmpcommand.		onRun press.	].(code = 8)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jzscommand := Jzs new:coll.		onRun := TheCommand new:jzscommand.		onRun press.	].(code = 9)ifTrue: [		coll:=OrderedCollection new.		coll add: interpreter_interface.		coll add:((interpreter_interface memory) at:(loc+1)).		jvscommand := Jvs new:coll.		onRun := TheCommand new:jvscommand.		onRun press.	].(code = 10)ifTrue: [		addcommand := Add new:interpreter_interface.		onRun := TheCommand new:addcommand.		onRun press.		interpreter_interface program_counter:(loc+1).	].(code = 11)ifTrue: [		hltcommand := Hlt new:interpreter_interface.		onRun := TheCommand new:hltcommand.		onRun press.	].loc:=interpreter_interface program_counter.(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).].</body></methods><methods><class-id>MainInterpreter class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MainInterpreter' 			#bounds: #(#{Graphics.Rectangle} 259 100 1022 581 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 88 0 25 0 ) 					#name: #Label1 					#label: 'State''s of the registers' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 68 0 62 0 ) 					#name: #Label2 					#label: 'Accumulator :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 68 0 94 0 ) 					#name: #Label3 					#label: 'Additional Register :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 68 0 126 0 ) 					#name: #Label4 					#label: 'Program Counter :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 68 0 158 0 ) 					#name: #Label5 					#label: 'Zero Result :' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 68 0 190 0 ) 					#name: #Label6 					#label: 'Overflow :' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 337 0 23 0 695 0 219 0 ) 					#name: #TextEditor1 					#model: #Program_Text 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 338 0 241 0 503 0 262 0 ) 					#name: #ActionButton1 					#model: #ExecuteCurrentLine 					#label: 'Execute Current Line' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 533 0 241 0 698 0 262 0 ) 					#name: #ActionButton2 					#model: #ExecuteCompleteProgram 					#label: 'Execute Complete Program' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 204 0 63 0 ) 					#name: #Label7 					#label: 'nil' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 204 0 95 0 ) 					#name: #Label8 					#label: 'nil' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 204 0 127 0 ) 					#name: #Label9 					#label: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 204 0 159 0 ) 					#name: #Label10 					#label: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 204 0 191 0 ) 					#name: #Label11 					#label: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 79 0 296 0 ) 					#name: #Label12 					#label: 'Error messages:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 136 0 321 0 ) 					#name: #Label13 ) ) ) )</body></methods><class><name>MainInterpreter</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>Accumulator Program_Counter Zero_Result Additional_Register Overflow Program_Text interpreter_interface interpreter program Console </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #MainInterpreter	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'Accumulator Program_Counter Zero_Result Additional_Register Overflow Program_Text interpreter_interface interpreter program Console  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>MainInterpreter</class-id> <category>aspects</category><body package="CS474" selector="Program_Text">Program_Text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Program_Text isNil		ifTrue:			[Program_Text := String new asValue]		ifFalse:			[Program_Text]</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll |interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll |interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			((((interpreter_interface memory) at:(loc+1))) = -1)ifTrue: [].			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll |interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			((((interpreter_interface memory) at:(loc+1))) = -1)ifTrue: [(self widgetAt: #Label13)labelString: 'You have used variables which you have not declared'.].			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll |interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			((((interpreter_interface memory) at:(loc+1))) = -1)ifTrue: [(self widgetAt: #Label13)labelString: 'You have used variables which you have not declared'.].			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).			((((interpreter_interface memory) at:(loc+1))) = -1)ifTrue: [(self widgetAt: #Label13)labelString: 'You have used variables which you have not declared'.].		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><methods><class-id>MainInterpreter</class-id> <category>actions</category><body package="CS474" selector="ExecuteCompleteProgram">ExecuteCompleteProgram| loc code ldacommand ldbcommand ldicommand stcommand xchcommand jmpcommand jvscommand jzscommand addcommand hltcommand onRun coll |interpreter := Interpreter new.interpreter_interface := interpreter.self AllocateMemory.loc := interpreter_interface program_counter.[loc&lt;257]whileTrue: [	code:=((interpreter_interface memory) at:loc).	(code =1)ifTrue: [			interpreter_interface program_counter:(loc+2).		].	(code = 2)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldacommand := Lda new:coll.			onRun := TheCommand new:ldacommand.			onRun press.			((((interpreter_interface memory) at:(loc+1))) = -1)ifTrue: [(self widgetAt: #Label13)labelString: 'You have used variables which you have not declared'.].			interpreter_interface program_counter:(loc+2).		].	(code = 3)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldbcommand := Ldb new:coll.			onRun := TheCommand new:ldbcommand.			onRun press.			interpreter_interface program_counter:(loc+2).			((((interpreter_interface memory) at:(loc+1))) = -1)ifTrue: [(self widgetAt: #Label13)labelString: 'You have used variables which you have not declared'.].		].		(code = 4)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			ldicommand := Ldi new:coll.			onRun := TheCommand new:ldicommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 5)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			stcommand := St new:coll.			onRun := TheCommand new:stcommand.			onRun press.			interpreter_interface program_counter:(loc+2).		].	(code = 6)ifTrue: [			xchcommand := Xch new:interpreter_interface.			onRun := TheCommand new:xchcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 7)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jmpcommand := Jmp new:coll.			onRun := TheCommand new:jmpcommand.			onRun press.		].	(code = 8)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jzscommand := Jzs new:coll.			onRun := TheCommand new:jzscommand.			onRun press.		].	(code = 9)ifTrue: [			coll:=OrderedCollection new.			coll add: interpreter_interface.			coll add:((interpreter_interface memory) at:(loc+1)).			jvscommand := Jvs new:coll.			onRun := TheCommand new:jvscommand.			onRun press.		].	(code = 10)ifTrue: [			addcommand := Add new:interpreter_interface.			onRun := TheCommand new:addcommand.			onRun press.			interpreter_interface program_counter:(loc+1).		].	(code = 11)ifTrue: [			hltcommand := Hlt new:interpreter_interface.			onRun := TheCommand new:hltcommand.			onRun press.		].	loc:=interpreter_interface program_counter.	].(self widgetAt: #Label7)labelString: ((interpreter_interface accumulator) printString).	(self widgetAt: #Label8)labelString: ((interpreter_interface additional_register) printString).	(self widgetAt: #Label9)labelString: ((interpreter_interface program_counter) printString).	(self widgetAt: #Label10)labelString: ((interpreter_interface zero_result) printString).	(self widgetAt: #Label11)labelString: ((interpreter_interface over_flow) printString).</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 22, 2018' '6:02:29 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 6:02:29 AM on March 22, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 22, 2018' '6:08:53 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 6:08:53 AM on March 22, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 22, 2018' '6:09:00 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 6:09:00 AM on March 22, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im' 'March 22, 2018' '6:27:37 AM')""An image file c:\Users\srujan\Documents\VisualWorks Projects\Project2\Project2.im was created at 6:27:37 AM on March 22, 2018."</do-it>